name: "Terraform Destroy"

on:
  repository_dispatch:
    types: [trigger-destroy]

# EmpÃªcher les exÃ©cutions concurrentes avec bootstrap.yml et bootstrap-manual.yml
concurrency:
  group: bootstrap-infrastructure
  cancel-in-progress: false

env:
  AWS_REGION: eu-west-3
  DDB_LOCK_TABLE: terraform-locks
  STATE_KEY: envs/dev/terraform.tfstate
  STATE_BUCKET_NAME: iot-playground-tfstate

jobs:
  destroy-infra:
    name: "Destroy Infra (Terraform)"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Fail if backend bucket missing (safety)
        run: |
          aws s3api head-bucket --bucket "${{ env.STATE_BUCKET_NAME }}" >/dev/null 2>&1 \
            || { echo "Backend bucket not found"; exit 1; }

      - name: Terraform init (S3 backend)
        working-directory: infra/envs/dev
        run: |
          terraform init -input=false \
            -backend-config="bucket=${{ env.STATE_BUCKET_NAME }}" \
            -backend-config="key=${{ env.STATE_KEY }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ env.DDB_LOCK_TABLE }}" \
            -backend-config="encrypt=true"

      - name: Pre-destroy cleanup (detach EIPs + empty buckets)
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -e

          # Identifier le VPC du projet pour Ã©viter de toucher aux autres ressources
          echo "ðŸ” Identifying project VPC..."
          PROJECT_VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Project,Values=iot-playground" "Name=tag:Environment,Values=dev" --query 'Vpcs[0].VpcId' --output text 2>/dev/null || echo "")
          
          if [ -z "$PROJECT_VPC_ID" ] || [ "$PROJECT_VPC_ID" = "None" ]; then
            echo "âš ï¸ Project VPC not found, will proceed with caution"
          else
            echo "âœ… Found project VPC: $PROJECT_VPC_ID"
          fi

          # 0) ArrÃªter et terminer toutes les instances EC2 du projet (elles bloquent l'IGW)
          echo "ðŸ›‘ Stopping and terminating EC2 instances in project VPC..."
          if [ -n "$PROJECT_VPC_ID" ] && [ "$PROJECT_VPC_ID" != "None" ]; then
            aws ec2 describe-instances --filters "Name=vpc-id,Values=$PROJECT_VPC_ID" "Name=instance-state-name,Values=running,stopped,stopping" --query 'Reservations[*].Instances[*].InstanceId' --output text | tr '\t' '\n' | \
            while read -r instance_id; do
              if [ -n "$instance_id" ] && [ "$instance_id" != "None" ]; then
                echo "Terminating instance: $instance_id"
                aws ec2 terminate-instances --instance-ids "$instance_id" || true
              fi
            done || true
            
            # Attendre que les instances soient terminÃ©es
            echo "â³ Waiting for instances to terminate (max 2 minutes)..."
            for i in {1..24}; do
              instance_count=$(aws ec2 describe-instances --filters "Name=vpc-id,Values=$PROJECT_VPC_ID" "Name=instance-state-name,Values=running,stopped,stopping,shutting-down" --query 'length(Reservations[*].Instances[*])' --output text 2>/dev/null || echo "0")
              if [ "$instance_count" = "0" ]; then
                echo "âœ… All instances terminated"
                break
              fi
              echo "Still waiting... ($instance_count instances remaining)"
              sleep 5
            done || true
          else
            echo "âš ï¸ Skipping EC2 instance cleanup (VPC not identified)"
          fi

          # 1) Dissocier et libÃ©rer TOUTES les EIP du VPC (y compris celles sans tags)
          echo "ðŸ”Œ Detaching and releasing ALL Elastic IPs in project VPC..."
          if [ -n "$PROJECT_VPC_ID" ] && [ "$PROJECT_VPC_ID" != "None" ]; then
            # MÃ©thode 1: Via tags (si prÃ©sents)
            aws ec2 describe-addresses --filters "Name=tag:Project,Values=iot-playground" --query 'Addresses[*].[AssociationId,AllocationId]' --output text | \
            while read -r assoc alloc; do
              if [ -n "$assoc" ] && [ "$assoc" != "None" ] && [ "$assoc" != "null" ]; then
                echo "Disassociate tagged EIP: $assoc"
                aws ec2 disassociate-address --association-id "$assoc" || true
              fi
              if [ -n "$alloc" ] && [ "$alloc" != "None" ]; then
                echo "Release tagged EIP: $alloc"
                aws ec2 release-address --allocation-id "$alloc" || true
              fi
            done || true
            
            # MÃ©thode 2: Via toutes les ENI du VPC (pour attraper les EIP sans tags)
            aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$PROJECT_VPC_ID" --query 'NetworkInterfaces[?Association.PublicIp].Association.AllocationId' --output text | tr '\t' '\n' | \
            while read -r alloc; do
              if [ -n "$alloc" ] && [ "$alloc" != "None" ] && [ "$alloc" != "null" ]; then
                echo "Found EIP allocation in VPC ENI: $alloc"
                # Dissocier d'abord
                assoc_id=$(aws ec2 describe-addresses --allocation-ids "$alloc" --query 'Addresses[0].AssociationId' --output text 2>/dev/null || echo "")
                if [ -n "$assoc_id" ] && [ "$assoc_id" != "None" ] && [ "$assoc_id" != "null" ]; then
                  echo "Disassociate EIP: $assoc_id"
                  aws ec2 disassociate-address --association-id "$assoc_id" || true
                  sleep 2
                fi
                echo "Release EIP: $alloc"
                aws ec2 release-address --allocation-id "$alloc" || true
              fi
            done || true
          else
            echo "âš ï¸ Skipping EIP cleanup (VPC not identified)"
          fi

          # 2) Forcer la suppression des NAT Gateways DU PROJET (ils gardent des EIP)
          echo "ðŸ—‘ï¸ Deleting NAT Gateways from project VPC..."
          if [ -n "$PROJECT_VPC_ID" ] && [ "$PROJECT_VPC_ID" != "None" ]; then
            aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$PROJECT_VPC_ID" "Name=state,Values=available,pending,deleting" --query 'NatGateways[*].[NatGatewayId,State]' --output text | \
            while read -r nat_id state; do
              if [ -n "$nat_id" ] && [ "$nat_id" != "None" ]; then
                echo "Deleting NAT Gateway: $nat_id (state: $state)"
                aws ec2 delete-nat-gateway --nat-gateway-id "$nat_id" || true
              fi
            done || true
            
            # Attendre que les NAT Gateways soient supprimÃ©s
            echo "â³ Waiting for NAT Gateways to be deleted (max 3 minutes)..."
            for i in {1..36}; do
              nat_count=$(aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$PROJECT_VPC_ID" "Name=state,Values=available,pending,deleting" --query 'length(NatGateways)' --output text)
              if [ "$nat_count" = "0" ]; then
                echo "âœ… All NAT Gateways deleted"
                break
              fi
              echo "Still waiting... ($nat_count NAT Gateways remaining)"
              sleep 5
            done || true
            
            # AprÃ¨s suppression des NAT Gateways, libÃ©rer leurs EIP orphelines DU PROJET uniquement
            echo "ðŸ”Œ Releasing NAT Gateway Elastic IPs (project only)..."
            # RÃ©cupÃ©rer toutes les EIP ET vÃ©rifier si elles sont dans notre VPC
            aws ec2 describe-addresses --filters "Name=domain,Values=vpc" --query 'Addresses[].[AllocationId,PublicIp,NetworkInterfaceId]' --output text | \
            while read -r alloc pub_ip eni_id; do
              if [ -n "$alloc" ] && [ "$alloc" != "None" ]; then
                # Si l'EIP n'a pas d'ENI (orpheline), vÃ©rifier si elle Ã©tait dans notre VPC
                if [ -z "$eni_id" ] || [ "$eni_id" = "None" ] || [ "$eni_id" = "null" ]; then
                  # VÃ©rifier via les tags si elle appartient au projet
                  vpc_check=$(aws ec2 describe-addresses --allocation-ids "$alloc" --query 'Addresses[0].Tags[?Key==`Project`].Value' --output text 2>/dev/null || echo "")
                  # âš ï¸ SÃ‰CURITÃ‰ : Ne libÃ©rer QUE les EIP taggÃ©es avec Project=iot-playground
                  if [ "$vpc_check" = "iot-playground" ]; then
                    echo "Release orphaned EIP: $alloc ($pub_ip)"
                    aws ec2 release-address --allocation-id "$alloc" || true
                  elif [ -z "$vpc_check" ]; then
                    # Pour les EIP sans tags, vÃ©rifier si elles Ã©taient attachÃ©es au VPC du projet via l'historique
                    eip_vpc=$(aws ec2 describe-addresses --allocation-ids "$alloc" --query 'Addresses[0].NetworkInterfaceOwnerId' --output text 2>/dev/null || echo "")
                    if [ -n "$eip_vpc" ] && [ "$eip_vpc" != "None" ] && [ "$eip_vpc" != "null" ]; then
                      # VÃ©rifier si le propriÃ©taire correspond Ã  notre VPC
                      echo "âš ï¸ Skipping untagged EIP $alloc (cannot confirm ownership, being cautious)"
                    else
                      echo "âš ï¸ Skipping untagged EIP $alloc (no project tag, being cautious)"
                    fi
                  else
                    echo "Skipping EIP $alloc (belongs to another project: $vpc_check)"
                  fi
                fi
              fi
            done || true
          else
            echo "âš ï¸ Skipping NAT Gateway cleanup (VPC not identified)"
          fi

          # 3) Supprimer les ENI non attachÃ©es DU VPC DU PROJET
          echo "ðŸ”Œ Deleting unattached ENIs from project VPC..."
          if [ -n "$PROJECT_VPC_ID" ] && [ "$PROJECT_VPC_ID" != "None" ]; then
            aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$PROJECT_VPC_ID" "Name=status,Values=available" --query 'NetworkInterfaces[*].[NetworkInterfaceId,Description]' --output text | \
            while read -r eni_id description; do
              if [ -n "$eni_id" ] && [ "$eni_id" != "None" ]; then
                # Ne pas toucher aux ENI par dÃ©faut
                if [[ "$description" != *"Primary network interface"* ]] && [[ "$description" != *"ELB"* ]]; then
                  echo "Deleting ENI: $eni_id"
                  aws ec2 delete-network-interface --network-interface-id "$eni_id" || true
                fi
              fi
            done || true
          else
            echo "âš ï¸ Skipping ENI cleanup (VPC not identified)"
          fi

          # 4) DÃ©tacher et supprimer l'IGW DU PROJET
          echo "ðŸŒ Detaching Internet Gateway from project VPC..."
          if [ -n "$PROJECT_VPC_ID" ] && [ "$PROJECT_VPC_ID" != "None" ]; then
            aws ec2 describe-internet-gateways --filters "Name=attachment.vpc-id,Values=$PROJECT_VPC_ID" --query 'InternetGateways[*].InternetGatewayId' --output text | \
            while read -r igw_id; do
              if [ -n "$igw_id" ] && [ "$igw_id" != "None" ]; then
                echo "Detaching IGW $igw_id from VPC $PROJECT_VPC_ID"
                aws ec2 detach-internet-gateway --internet-gateway-id "$igw_id" --vpc-id "$PROJECT_VPC_ID" || true
                sleep 2
                echo "Deleting IGW $igw_id"
                aws ec2 delete-internet-gateway --internet-gateway-id "$igw_id" || true
              fi
            done || true
          else
            echo "âš ï¸ Skipping IGW cleanup (VPC not identified)"
          fi

          # 5) Vider uniquement le bucket reports (PAS le bucket backend terraform)
          BUCKET="iot-playground-dev-reports"
          echo "ðŸ—‘ï¸ Cleaning bucket: $BUCKET"
          # VÃ©rifier si le bucket existe
          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            # Supprime toutes les versions
            aws s3api list-object-versions --bucket "$BUCKET" --query 'Versions[].{K:Key,V:VersionId}' --output text 2>/dev/null | \
            while read -r key ver; do
              if [ -n "$key" ] && [ -n "$ver" ] && [ "$key" != "None" ] && [ "$ver" != "None" ]; then
                echo "Deleting version: $key ($ver)"
                aws s3api delete-object --bucket "$BUCKET" --key "$key" --version-id "$ver" || true
              fi
            done || true

            # Supprime delete markers
            aws s3api list-object-versions --bucket "$BUCKET" --query 'DeleteMarkers[].{K:Key,V:VersionId}' --output text 2>/dev/null | \
            while read -r key ver; do
              if [ -n "$key" ] && [ -n "$ver" ] && [ "$key" != "None" ] && [ "$ver" != "None" ]; then
                echo "Deleting marker: $key ($ver)"
                aws s3api delete-object --bucket "$BUCKET" --key "$key" --version-id "$ver" || true
              fi
            done || true

            # Supprime objets restants
            aws s3 rm "s3://$BUCKET" --recursive || true
            echo "Bucket $BUCKET cleaned"
          else
            echo "Bucket $BUCKET does not exist, skipping"
          fi

          echo "âœ… Pre-destroy cleanup finished (only project resources affected)."

      # Terraform demande toujours les variables dÃ©clarÃ©es ; on passe les secrets mÃªme pour destroy
      - name: Terraform destroy
        working-directory: infra/envs/dev
        run: |
          terraform destroy -auto-approve -input=false \
            -var="state_bucket_name=${{ env.STATE_BUCKET_NAME }}" \
            -var="xray_access_key_id=dummy" \
            -var="xray_secret_access_key=dummy"

      - name: Clean existing secrets before destroy
        run: |
          echo "Cleaning existing secrets to allow recreation..."
          aws secretsmanager delete-secret --secret-id iot-playground-rds-credentials-dev --force-delete-without-recovery || echo "RDS secret not found or already deleted"
          aws secretsmanager delete-secret --secret-id iot-playground-xray-credentials-dev --force-delete-without-recovery || echo "X-Ray secret not found or already deleted"
          echo "Secrets cleanup completed"

  teardown-backend:
    name: "Teardown Backend (S3 + DynamoDB)"
    runs-on: ubuntu-latest
    needs: destroy-infra
    if: ${{ needs.destroy-infra.result == 'success' }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Delete state object(s) from S3 (idempotent)
        run: |
          BUCKET="${{ env.STATE_BUCKET_NAME }}"
          KEY="${{ env.STATE_KEY }}"
          # Supprime la clÃ© de state et d'Ã©ventuelles versions/locks
          aws s3 rm "s3://$BUCKET/$KEY" --recursive || true
          # Si le bucket est versionnÃ©, on purge tout
          aws s3api list-object-versions --bucket "$BUCKET" --query 'Versions[].{K:Key,V:VersionId}' --output text 2>/dev/null | \
          awk '{print $1,$2}' | while read -r k v; do
            aws s3api delete-object --bucket "$BUCKET" --key "$k" --version-id "$v" || true
          done
          aws s3api list-object-versions --bucket "$BUCKET" --query 'DeleteMarkers[].{K:Key,V:VersionId}' --output text 2>/dev/null | \
          awk '{print $1,$2}' | while read -r k v; do
            aws s3api delete-object --bucket "$BUCKET" --key "$k" --version-id "$v" || true
          done

      - name: Delete S3 bucket (idempotent)
        run: |
          BUCKET="${{ env.STATE_BUCKET_NAME }}"
          # s3 rm rÃ©cursif (au cas oÃ¹) puis delete-bucket
          aws s3 rm "s3://$BUCKET" --recursive || true
          aws s3api delete-bucket --bucket "$BUCKET" || true

      - name: Clean DynamoDB deployments table
        run: |
          TABLE="iot-playground-dev-deployments"
          echo "Cleaning DynamoDB table: $TABLE"
          
          # VÃ©rifier si la table existe
          if aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1; then
            echo "Table exists, scanning and deleting all items..."
            
            # Scanner la table et supprimer tous les items (un par ligne)
            aws dynamodb scan --table-name "$TABLE" --attributes-to-get "deployment_id" --query "Items[].deployment_id.S" --output text | tr '\t' '\n' | \
            while read -r deployment_id; do
              if [ -n "$deployment_id" ] && [ "$deployment_id" != "None" ]; then
                echo "Deleting deployment: $deployment_id"
                aws dynamodb delete-item --table-name "$TABLE" --key "{\"deployment_id\":{\"S\":\"$deployment_id\"}}" || true
              fi
            done || true
            
            echo "DynamoDB table $TABLE cleaned"
          else
            echo "Table $TABLE does not exist, skipping"
          fi

      - name: Delete DynamoDB lock table (idempotent)
        run: |
          TABLE="${{ env.DDB_LOCK_TABLE }}"
          aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1 || exit 0
          aws dynamodb delete-table --table-name "$TABLE"

      - name: Force Delete Secret Manager
        run: |
          aws secretsmanager delete-secret --secret-id iot-playground-rds-credentials-dev --force-delete-without-recovery || true
          aws secretsmanager delete-secret --secret-id iot-playground-xray-credentials-dev --force-delete-without-recovery || true

      - name: Force Delete API Gateway Resources
        run: |
          # Supprimer toutes les API Gateway REST APIs du projet
          aws apigateway get-rest-apis --query "items[?contains(name, 'iot-playground')].id" --output text | \
          while read -r api_id; do
            if [ -n "$api_id" ] && [ "$api_id" != "None" ]; then
              echo "Deleting API Gateway: $api_id"
              aws apigateway delete-rest-api --rest-api-id "$api_id" || true
            fi
          done || true
