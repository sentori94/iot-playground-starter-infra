{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"IoT Playground Infrastructure","text":""},{"location":"#but-du-projet","title":"\ud83c\udfaf But du Projet","text":"<p>Ce projet est une plateforme de d\u00e9monstration con\u00e7ue pour comparer deux approches d'architecture cloud sur AWS dans un contexte IoT (Internet of Things). L'objectif est de permettre \u00e0 des utilisateurs de simuler des capteurs IoT qui g\u00e9n\u00e8rent des donn\u00e9es de temp\u00e9rature en temps r\u00e9el, tout en mesurant les diff\u00e9rences de co\u00fbts, performances et complexit\u00e9 entre deux architectures modernes.</p>"},{"location":"#contexte-pedagogique","title":"Contexte P\u00e9dagogique","text":"<p>L'application permet de : - D\u00e9marrer des simulations de capteurs IoT (runs) avec une dur\u00e9e et un intervalle configurables - Ing\u00e9rer des donn\u00e9es de capteurs (temp\u00e9rature, humidit\u00e9, pression) en temps r\u00e9el - Visualiser les m\u00e9triques via des dashboards Grafana - Comparer les deux architectures c\u00f4te \u00e0 c\u00f4te depuis une interface frontend unique</p>"},{"location":"#pourquoi-deux-architectures","title":"Pourquoi Deux Architectures ?","text":"<p>Le projet impl\u00e9mente deux backends distincts pour r\u00e9pondre \u00e0 la question : \"Quelle architecture AWS choisir pour une application IoT ?\"</p> <ol> <li> <p>Architecture ECS (Classique) : Approche traditionnelle avec conteneurs Docker, base de donn\u00e9es relationnelle et monitoring Prometheus. Adapt\u00e9e pour des charges constantes et pr\u00e9visibles.</p> </li> <li> <p>Architecture Serverless : Approche moderne avec Lambda, DynamoDB et CloudWatch. Optimis\u00e9e pour des charges variables avec un mod\u00e8le de co\u00fbts pay-per-use.</p> </li> </ol> <p>Le frontend Angular offre un onglet de s\u00e9lection permettant de basculer entre les deux modes et de comparer l'exp\u00e9rience utilisateur.</p>"},{"location":"#structure-du-projet","title":"\ud83c\udfd7\ufe0f Structure du Projet","text":"<p>Le projet est organis\u00e9 en modules Terraform r\u00e9utilisables permettant de d\u00e9ployer facilement l'une ou l'autre architecture :</p>"},{"location":"#organisation-des-environnements","title":"Organisation des Environnements","text":"<ul> <li><code>infra/envs/dev/</code> : Configuration compl\u00e8te pour l'architecture ECS avec Spring Boot, RDS PostgreSQL, Prometheus et Grafana</li> <li><code>infra/envs/serverless-dev/</code> : Configuration pour l'architecture Serverless avec Lambda Python, DynamoDB et CloudWatch</li> <li><code>infra/modules/</code> : Modules Terraform partag\u00e9s (r\u00e9seau, base de donn\u00e9es, compute, monitoring)</li> </ul>"},{"location":"#deploiement-avec-github-actions","title":"D\u00e9ploiement avec GitHub Actions","text":"<p>Les workflows CI/CD sont configur\u00e9s pour d\u00e9ployer automatiquement : - Les Lambdas et l'API Gateway via <code>deploy-serverless-unified.yml</code> - L'infrastructure Grafana optionnelle (ECS + VPC) de mani\u00e8re ind\u00e9pendante - Destruction cibl\u00e9e des ressources avec <code>destroy-serverless.yml</code></p>"},{"location":"#domaines-personnalises","title":"Domaines Personnalis\u00e9s","text":"<p>Chaque architecture dispose de son propre domaine DNS avec certificat HTTPS : - <code>api-lambda-iot.sentori-studio.com</code> \u2192 API Gateway (Serverless) - <code>grafana-lambda-iot.sentori-studio.com</code> \u2192 Grafana (Serverless)</p>"},{"location":"#comparaison-des-architectures","title":"\ud83d\udcca Comparaison des Architectures","text":"Crit\u00e8re ECS Classic Serverless Langage Java (Spring Boot) Python 3.11 Base de donn\u00e9es PostgreSQL (RDS) DynamoDB Co\u00fbt (idle) ~$80/mois ~$1/mois Co\u00fbt (actif) ~$80/mois (fixe) Variable selon usage Scalabilit\u00e9 Auto-scaling ECS Auto-scaling Lambda Cold Start Aucun ~1-2s Monitoring Prometheus CloudWatch Logs"},{"location":"#cas-dusage-recommandes","title":"Cas d'Usage Recommand\u00e9s","text":"<p>ECS : Trafic constant et pr\u00e9visible, latence critique, connexions persistantes Serverless : Trafic sporadique, pics de charge, budget limit\u00e9, pay-per-use</p>"},{"location":"#demarrage-rapide","title":"\ud83d\ude80 D\u00e9marrage Rapide","text":"<p>Pour d\u00e9ployer l'architecture Serverless (recommand\u00e9 pour commencer) :</p> <ol> <li>Configurer AWS CLI avec les credentials</li> <li>Via GitHub Actions : Deploy Serverless (Unified) \u2192 Component: <code>lambdas</code> \u2192 Action: <code>apply</code></li> <li>Attendre ~5 minutes</li> <li>Tester l'API : <code>curl https://api-lambda-iot.sentori-studio.com/api/runs/can-start</code></li> </ol> <p>Voir le guide complet pour plus de d\u00e9tails.</p>"},{"location":"#organisation-du-projet","title":"\ud83d\udcc1 Organisation du Projet","text":"<p>Le projet est structur\u00e9 en environnements Terraform s\u00e9par\u00e9s :</p> <ul> <li><code>infra/envs/dev/</code> : Architecture ECS compl\u00e8te (Spring Boot + PostgreSQL)</li> <li><code>infra/envs/serverless-dev/</code> : Architecture Serverless (Lambda + DynamoDB)  </li> <li><code>infra/modules/</code> : Modules Terraform r\u00e9utilisables (r\u00e9seau, compute, BDD, monitoring)</li> <li><code>.github/workflows/</code> : Workflows CI/CD pour d\u00e9ploiement automatis\u00e9</li> </ul> <p>Les workflows GitHub Actions permettent de d\u00e9ployer chaque composant ind\u00e9pendamment (lambdas, grafana) ou ensemble (full).</p>"},{"location":"#navigation","title":"\ud83d\udd17 Navigation","text":"<ul> <li>Architecture : ECS | Serverless | Comparaison</li> <li>D\u00e9ploiement : Guide Rapide</li> <li>API : Run Controller | Sensor Controller</li> </ul>"},{"location":"api/run-controller/","title":"API Run Controller","text":"<p>Gestion du cycle de vie des simulations (runs).</p>"},{"location":"api/run-controller/#base-url","title":"\ud83c\udfaf Base URL","text":"<ul> <li>Serverless : <code>https://api-lambda-iot.sentori-studio.com</code></li> <li>ECS : <code>https://api-ecs-iot.sentori-studio.com</code> (futur)</li> </ul>"},{"location":"api/run-controller/#endpoints","title":"\ud83d\udccb Endpoints","text":""},{"location":"api/run-controller/#get-apirunscan-start","title":"GET <code>/api/runs/can-start</code>","text":"<p>V\u00e9rifie si on peut d\u00e9marrer une nouvelle simulation.</p> <p>Headers <pre><code>(aucun header requis)\n</code></pre></p> <p>Response 200 <pre><code>{\n  \"canStart\": true,\n  \"currentRunning\": 2,\n  \"maxAllowed\": 5,\n  \"available\": 3\n}\n</code></pre></p>"},{"location":"api/run-controller/#post-apirunsstart","title":"POST <code>/api/runs/start</code>","text":"<p>D\u00e9marre une nouvelle simulation.</p> <p>Headers <pre><code>Content-Type: application/json\nX-User: username\n</code></pre></p> <p>Body <pre><code>{\n  \"duration\": 60,\n  \"interval\": 5\n}\n</code></pre></p> <p>Response 201 <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"username\": \"test-user\",\n  \"status\": \"RUNNING\",\n  \"startedAt\": \"2025-01-15T10:30:00Z\",\n  \"duration\": 60,\n  \"interval\": 5,\n  \"params\": {\n    \"duration\": 60,\n    \"interval\": 5\n  },\n  \"grafanaUrl\": \"https://grafana-lambda-iot.sentori-studio.com/d/...\"\n}\n</code></pre></p> <p>Response 400 (limite atteinte) <pre><code>{\n  \"error\": \"Maximum concurrent runs reached\",\n  \"currentRunning\": 5,\n  \"maxAllowed\": 5\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apirunsrunning","title":"GET <code>/api/runs/running</code>","text":"<p>Liste tous les runs en cours (tous utilisateurs).</p> <p>Response 200 <pre><code>[\n  {\n    \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"username\": \"user1\",\n    \"status\": \"RUNNING\",\n    \"startedAt\": \"2025-01-15T10:30:00Z\",\n    \"duration\": 60,\n    \"interval\": 5\n  },\n  {\n    \"id\": \"660e8400-e29b-41d4-a716-446655440001\",\n    \"username\": \"user2\",\n    \"status\": \"RUNNING\",\n    \"startedAt\": \"2025-01-15T10:32:00Z\",\n    \"duration\": 120,\n    \"interval\": 10\n  }\n]\n</code></pre></p>"},{"location":"api/run-controller/#post-apirunsidfinish","title":"POST <code>/api/runs/{id}/finish</code>","text":"<p>Termine un run en cours.</p> <p>Path Parameters - <code>id</code> : UUID du run</p> <p>Headers <pre><code>Content-Type: application/json\n</code></pre></p> <p>Body (optionnel) <pre><code>{\n  \"errorMessage\": \"Simulation interrupted by user\"\n}\n</code></pre></p> <p>Response 200 <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"username\": \"test-user\",\n  \"status\": \"COMPLETED\",\n  \"startedAt\": \"2025-01-15T10:30:00Z\",\n  \"finishedAt\": \"2025-01-15T10:31:00Z\",\n  \"duration\": 60,\n  \"interval\": 5\n}\n</code></pre></p> <p>Response 404 <pre><code>{\n  \"error\": \"Run not found\"\n}\n</code></pre></p> <p>Response 400 <pre><code>{\n  \"error\": \"Run is not running\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#post-apirunsinterrupt-all","title":"POST <code>/api/runs/interrupt-all</code>","text":"<p>Interrompt toutes les simulations en cours (tous utilisateurs).</p> <p>Response 200 <pre><code>{\n  \"interrupted\": 3,\n  \"message\": \"3 simulation(s) interrupted\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apirunsid","title":"GET <code>/api/runs/{id}</code>","text":"<p>D\u00e9tails d'un run sp\u00e9cifique.</p> <p>Path Parameters - <code>id</code> : UUID du run</p> <p>Response 200 <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"username\": \"test-user\",\n  \"status\": \"COMPLETED\",\n  \"startedAt\": \"2025-01-15T10:30:00Z\",\n  \"finishedAt\": \"2025-01-15T10:31:00Z\",\n  \"duration\": 60,\n  \"interval\": 5,\n  \"params\": {\n    \"duration\": 60,\n    \"interval\": 5\n  },\n  \"grafanaUrl\": \"https://grafana-lambda-iot.sentori-studio.com/d/...\"\n}\n</code></pre></p> <p>Response 404 <pre><code>{\n  \"error\": \"Run not found\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apiruns","title":"GET <code>/api/runs</code>","text":"<p>Liste pagin\u00e9e de tous les runs.</p> <p>Query Parameters - <code>limit</code> (optional) : Nombre d'items par page (d\u00e9faut: 20) - <code>lastKey</code> (optional) : Cl\u00e9 de pagination (base64)</p> <p>Response 200 <pre><code>{\n  \"items\": [\n    {\n      \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"username\": \"test-user\",\n      \"status\": \"COMPLETED\",\n      \"startedAt\": \"2025-01-15T10:30:00Z\",\n      \"finishedAt\": \"2025-01-15T10:31:00Z\"\n    }\n  ],\n  \"count\": 20,\n  \"nextKey\": \"eyJpZCI6ICIuLi4ifQ==\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apirunsall","title":"GET <code>/api/runs/all</code>","text":"<p>Tous les runs sans pagination.</p> <p>Response 200 <pre><code>[\n  {\n    \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"username\": \"test-user\",\n    \"status\": \"COMPLETED\",\n    \"startedAt\": \"2025-01-15T10:30:00Z\"\n  },\n  ...\n]\n</code></pre></p>"},{"location":"api/run-controller/#etats-du-run","title":"\ud83d\udcca \u00c9tats du Run","text":"<p>Un run peut avoir 4 \u00e9tats :</p> <ul> <li>RUNNING : Simulation en cours</li> <li>COMPLETED : Simulation termin\u00e9e avec succ\u00e8s</li> <li>FAILED : Simulation termin\u00e9e avec erreur</li> <li>INTERRUPTED : Simulation interrompue manuellement</li> </ul> <p>Transitions : <code>RUNNING</code> \u2192 <code>COMPLETED</code> / <code>FAILED</code> / <code>INTERRUPTED</code> (\u00e9tats finaux)</p>"},{"location":"api/run-controller/#authentification","title":"\ud83d\udd10 Authentification","text":"<p>Actuellement : Header <code>X-User</code></p> <pre><code>curl -H \"X-User: mon-username\" \\\n  https://api-lambda-iot.sentori-studio.com/api/runs/running\n</code></pre>"},{"location":"api/run-controller/#codes-derreur","title":"\ud83d\udea8 Codes d'Erreur","text":"Code Description 200 Success 201 Created 400 Bad Request (limite, validation) 404 Run not found 405 Method not allowed 500 Internal server error"},{"location":"api/run-controller/#liens","title":"\ud83d\udd17 Liens","text":"<ul> <li>Sensor Controller API</li> <li>Guide Simulations</li> </ul>"},{"location":"api/sensor-controller/","title":"API Sensor Controller","text":"<p>Gestion de l'ingestion et r\u00e9cup\u00e9ration des donn\u00e9es de capteurs IoT.</p>"},{"location":"api/sensor-controller/#base-url","title":"\ud83c\udfaf Base URL","text":"<ul> <li>Serverless : <code>https://api-lambda-iot.sentori-studio.com</code></li> <li>ECS : <code>https://api-ecs-iot.sentori-studio.com</code> (futur)</li> </ul>"},{"location":"api/sensor-controller/#endpoints","title":"\ud83d\udccb Endpoints","text":""},{"location":"api/sensor-controller/#post-apisensorsdata","title":"POST <code>/api/sensors/data</code>","text":"<p>Ing\u00e8re une mesure de capteur dans le syst\u00e8me.</p> <p>Headers <pre><code>Content-Type: application/json\nX-User: username\nX-Run-Id: run-uuid\n</code></pre></p> <p>Body <pre><code>{\n  \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"sensorId\": \"sensor-001\",\n  \"temperature\": 23.5,\n  \"humidity\": 65.2,\n  \"pressure\": 1013.25\n}\n</code></pre></p> <p>Response 201 <pre><code>{\n  \"id\": \"660e8400-e29b-41d4-a716-446655440001\",\n  \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"sensorId\": \"sensor-001\",\n  \"timestamp\": \"2025-01-15T10:30:05Z\",\n  \"temperature\": 23.5,\n  \"humidity\": 65.2,\n  \"pressure\": 1013.25\n}\n</code></pre></p> <p>Response 400 (validation error) <pre><code>{\n  \"error\": \"Invalid sensor data\",\n  \"details\": \"temperature must be a number\"\n}\n</code></pre></p> <p>Response 404 (run not found) <pre><code>{\n  \"error\": \"Run not found\"\n}\n</code></pre></p>"},{"location":"api/sensor-controller/#get-apisensorsdata","title":"GET <code>/api/sensors/data</code>","text":"<p>R\u00e9cup\u00e8re les donn\u00e9es de capteurs filtr\u00e9es.</p> <p>Query Parameters - <code>runId</code> (optional) : UUID du run - <code>sensorId</code> (optional) : ID du capteur - <code>startDate</code> (optional) : Date de d\u00e9but (ISO 8601) - <code>endDate</code> (optional) : Date de fin (ISO 8601) - <code>limit</code> (optional) : Nombre max de r\u00e9sultats (d\u00e9faut: 100)</p> <p>Examples <pre><code># Toutes les donn\u00e9es d'un run\nGET /api/sensors/data?runId=550e8400-e29b-41d4-a716-446655440000\n\n# Donn\u00e9es d'un capteur sp\u00e9cifique\nGET /api/sensors/data?sensorId=sensor-001\n\n# Donn\u00e9es dans une p\u00e9riode\nGET /api/sensors/data?startDate=2025-01-15T10:00:00Z&amp;endDate=2025-01-15T11:00:00Z\n</code></pre></p> <p>Response 200 <pre><code>[\n  {\n    \"id\": \"660e8400-e29b-41d4-a716-446655440001\",\n    \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"sensorId\": \"sensor-001\",\n    \"timestamp\": \"2025-01-15T10:30:05Z\",\n    \"temperature\": 23.5,\n    \"humidity\": 65.2,\n    \"pressure\": 1013.25\n  },\n  {\n    \"id\": \"660e8400-e29b-41d4-a716-446655440002\",\n    \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"sensorId\": \"sensor-001\",\n    \"timestamp\": \"2025-01-15T10:30:10Z\",\n    \"temperature\": 23.7,\n    \"humidity\": 65.0,\n    \"pressure\": 1013.20\n  }\n]\n</code></pre></p>"},{"location":"api/sensor-controller/#format-des-donnees","title":"\ud83d\udcca Format des Donn\u00e9es","text":""},{"location":"api/sensor-controller/#capteur-simple-temperature-uniquement","title":"Capteur Simple (Temp\u00e9rature uniquement)","text":"<pre><code>{\n  \"runId\": \"...\",\n  \"sensorId\": \"temp-sensor-01\",\n  \"temperature\": 23.5\n}\n</code></pre>"},{"location":"api/sensor-controller/#capteur-complet-temperature-humidite-pression","title":"Capteur Complet (Temp\u00e9rature, Humidit\u00e9, Pression)","text":"<pre><code>{\n  \"runId\": \"...\",\n  \"sensorId\": \"multi-sensor-01\",\n  \"temperature\": 23.5,\n  \"humidity\": 65.2,\n  \"pressure\": 1013.25\n}\n</code></pre>"},{"location":"api/sensor-controller/#flux-dingestion-typique","title":"\ud83d\udd04 Flux d'Ingestion Typique","text":"<ol> <li>Frontend d\u00e9marre une simulation via <code>POST /api/runs/start</code></li> <li>R\u00e9cup\u00e8re le <code>runId</code> dans la r\u00e9ponse</li> <li>Toutes les N secondes (interval configur\u00e9) :</li> <li>G\u00e9n\u00e8re des donn\u00e9es de capteur (temp\u00e9rature al\u00e9atoire)</li> <li>Envoie via <code>POST /api/sensors/data</code> avec le <code>runId</code></li> <li>Continue jusqu'\u00e0 la fin de la dur\u00e9e configur\u00e9e</li> <li>Termine la simulation via <code>POST /api/runs/{id}/finish</code></li> </ol>"},{"location":"api/sensor-controller/#authentification","title":"\ud83d\udd10 Authentification","text":"<p>Les headers suivants sont requis : - <code>X-User</code> : Identifiant de l'utilisateur (string) - <code>X-Run-Id</code> : UUID du run associ\u00e9 (optionnel sur GET)</p>"},{"location":"api/sensor-controller/#codes-derreur","title":"\ud83d\udea8 Codes d'Erreur","text":"Code Description 201 Created 200 Success (GET) 400 Bad Request (validation) 404 Run not found 405 Method not allowed 500 Internal server error"},{"location":"api/sensor-controller/#exemples","title":"\ud83d\udca1 Exemples","text":""},{"location":"api/sensor-controller/#exemple-complet-avec-curl","title":"Exemple complet avec cURL","text":"<pre><code># 1. D\u00e9marrer un run\nRUN_ID=$(curl -X POST https://api-lambda-iot.sentori-studio.com/api/runs/start \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-User: demo-user\" \\\n  -d '{\"duration\": 60, \"interval\": 5}' | jq -r '.id')\n\n# 2. Ing\u00e9rer des donn\u00e9es\ncurl -X POST https://api-lambda-iot.sentori-studio.com/api/sensors/data \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-User: demo-user\" \\\n  -H \"X-Run-Id: $RUN_ID\" \\\n  -d \"{\n    \\\"runId\\\": \\\"$RUN_ID\\\",\n    \\\"sensorId\\\": \\\"temp-sensor-01\\\",\n    \\\"temperature\\\": 23.5\n  }\"\n\n# 3. R\u00e9cup\u00e9rer les donn\u00e9es\ncurl \"https://api-lambda-iot.sentori-studio.com/api/sensors/data?runId=$RUN_ID\"\n</code></pre>"},{"location":"api/sensor-controller/#liens","title":"\ud83d\udd17 Liens","text":"<ul> <li>Run Controller API</li> <li>Guide Simulations</li> </ul>"},{"location":"architecture/comparison/","title":"Comparaison ECS vs Serverless","text":""},{"location":"architecture/comparison/#objectif-de-la-comparaison","title":"\ud83c\udfaf Objectif de la Comparaison","text":"<p>Ce projet permet de mesurer concr\u00e8tement les diff\u00e9rences entre une architecture conteneuris\u00e9e (ECS) et une architecture serverless (Lambda) sur AWS. Les deux impl\u00e9mentent exactement la m\u00eame fonctionnalit\u00e9 (simulation de capteurs IoT), permettant une comparaison objective.</p>"},{"location":"architecture/comparison/#tableau-comparatif","title":"\ud83d\udcca Tableau Comparatif","text":"Aspect ECS Classic Serverless Lambda Runtime Spring Boot (Java) Python 3.11 Base de donn\u00e9es PostgreSQL (RDS) DynamoDB Compute ECS Fargate (Always-on) Lambda (On-demand) Scaling Auto-scaling ECS Auto-scaling Lambda Cold Start \u274c Aucun \u26a0\ufe0f ~1-2s (first request) Co\u00fbt idle ~$80/mois ~$1/mois (sans Grafana) Co\u00fbt actif ~$80/mois (fixe) Variable selon usage Monitoring Prometheus CloudWatch Logs Grafana Datasource Prometheus Datasource CloudWatch HTTPS \u2705 ALB + ACM \u2705 API Gateway + ACM Authentification Header X-User Header X-User Limite concurrent Configurable ECS 5 runs globaux"},{"location":"architecture/comparison/#cas-dusage-recommandes","title":"\ud83c\udfaf Cas d'Usage Recommand\u00e9s","text":""},{"location":"architecture/comparison/#ecs-classic","title":"ECS Classic","text":"<p>Quand choisir ECS : - Trafic constant et pr\u00e9visible (&gt; 100 req/min en continu) - Besoin de latence ultra-faible (&lt; 50ms) - Applications avec \u00e9tat ou connexions persistantes - Workloads de longue dur\u00e9e (&gt; 15 minutes)</p> <p>Avantages ECS : - \u2705 Pas de cold start - \u2705 Connexions persistantes (BDD, cache) - \u2705 Latence pr\u00e9visible - \u2705 Debugging plus simple (logs structur\u00e9s) - \u2705 \u00c9cosyst\u00e8me Java mature</p> <p>Inconv\u00e9nients ECS : - \u274c Co\u00fbt fixe m\u00eame sans trafic - \u274c Gestion de l'infrastructure - \u274c Scaling moins r\u00e9actif</p>"},{"location":"architecture/comparison/#serverless-lambda","title":"Serverless Lambda","text":"<p>Quand choisir Serverless : - Trafic sporadique ou impr\u00e9visible - Budget limit\u00e9 (pay-per-use) - Pics de charge importants n\u00e9cessitant un scaling rapide - Prototypes ou applications en phase de test</p> <p>Avantages Serverless : - \u2705 Pay-per-use (co\u00fbt = usage r\u00e9el) - \u2705 Scaling automatique infini - \u2705 Pas de gestion serveur - \u2705 DynamoDB tr\u00e8s performant</p> <p>Inconv\u00e9nients Serverless : - \u274c Cold start (~1-2s) - \u274c Timeout max 15 minutes - \u274c Debugging plus complexe - \u274c Vendor lock-in AWS</p>"},{"location":"architecture/comparison/#analyse-couts-detaillee","title":"\ud83d\udcb0 Analyse Co\u00fbts D\u00e9taill\u00e9e","text":""},{"location":"architecture/comparison/#scenario-1000-reqjour","title":"Sc\u00e9nario : 1000 req/jour","text":"ECSServerless Ressource Co\u00fbt mensuel Fargate (1 task, 0.5 vCPU, 1 GB) ~$30 RDS PostgreSQL (db.t3.micro) ~$15 ALB ~$16 Prometheus ECS ~$15 Grafana ECS ~$15 TOTAL ~$90/mois Ressource Co\u00fbt mensuel Lambda (30k invocations) ~$0.01 DynamoDB (on-demand, 30k writes) ~$0.40 API Gateway (30k requests) ~$0.10 CloudWatch Logs (5 GB) ~$2.50 Grafana ECS (si actif) ~$40 VPC (NAT, IGW pour Grafana) ~$40 TOTAL (avec Grafana) ~$83/mois TOTAL (sans Grafana) ~$3/mois"},{"location":"architecture/comparison/#scenario-100k-reqjour","title":"Sc\u00e9nario : 100k req/jour","text":"ECSServerless Ressource Co\u00fbt mensuel Fargate (2 tasks, 1 vCPU, 2 GB) ~$60 RDS PostgreSQL (db.t3.small) ~$30 ALB ~$20 Prometheus ECS ~$15 Grafana ECS ~$15 TOTAL ~$140/mois Ressource Co\u00fbt mensuel Lambda (3M invocations) ~$1.20 DynamoDB (3M writes) ~$40 API Gateway (3M requests) ~$10 CloudWatch Logs (50 GB) ~$25 Grafana ECS ~$40 VPC ~$40 TOTAL ~$156/mois"},{"location":"architecture/comparison/#conclusion-couts","title":"Conclusion Co\u00fbts","text":"<p>Analyse</p> <ul> <li>&lt; 10k req/jour \u2192 Serverless beaucoup moins cher</li> <li>10k - 50k req/jour \u2192 \u00c9quivalent</li> <li>&gt; 100k req/jour \u2192 ECS plus \u00e9conomique</li> </ul>"},{"location":"architecture/comparison/#performance","title":"\u26a1 Performance","text":""},{"location":"architecture/comparison/#latence-observee","title":"Latence Observ\u00e9e","text":"<p>ECS (toujours chaud) : P50 ~50ms, P95 ~100ms, P99 ~150ms Serverless (warm) : P50 ~80ms, P95 ~200ms, P99 ~500ms Serverless (cold start) : P50 ~1500ms, P95 ~2500ms, P99 ~3500ms</p> <p>Le cold start est le principal inconv\u00e9nient du Serverless, mais il ne se produit que sur la premi\u00e8re requ\u00eate ou apr\u00e8s une p\u00e9riode d'inactivit\u00e9.</p>"},{"location":"architecture/comparison/#throughput","title":"Throughput","text":"Architecture Max Throughput Scaling Time ECS ~1000 req/s (2 tasks) 2-3 minutes Serverless ~10000 req/s (1000 lambdas) &lt; 10 secondes"},{"location":"architecture/comparison/#recommandation-pour-ce-projet","title":"\ud83c\udf93 Recommandation pour ce Projet","text":"<p>Approche P\u00e9dagogique</p> <p>Les deux architectures sont d\u00e9ploy\u00e9es pour permettre la comparaison :</p> <ul> <li>ECS : <code>infra/envs/dev/</code></li> <li>Serverless : <code>infra/envs/serverless-dev/</code></li> </ul> <p>\u2192 Choix dans le frontend : \"Mode ECS\" vs \"Mode Serverless\"</p>"},{"location":"architecture/ecs/","title":"Architecture ECS (Classic)","text":""},{"location":"architecture/ecs/#vue-densemble","title":"\ud83c\udfaf Vue d'ensemble","text":"<p>L'architecture ECS repr\u00e9sente l'approche traditionnelle avec des conteneurs Docker qui tournent en permanence sur AWS Fargate. Cette architecture est adapt\u00e9e aux applications n\u00e9cessitant une latence constante et pr\u00e9visible, avec des connexions persistantes vers la base de donn\u00e9es.</p>"},{"location":"architecture/ecs/#composants-principaux","title":"\ud83c\udfd7\ufe0f Composants Principaux","text":""},{"location":"architecture/ecs/#ecs-fargate","title":"ECS Fargate","text":"<p>Les conteneurs Spring Boot tournent sur Fargate (serverless containers) sans avoir \u00e0 g\u00e9rer les instances EC2. Chaque t\u00e2che ECS a 0.5 vCPU et 1 GB de m\u00e9moire, suffisant pour l'application IoT Playground.</p>"},{"location":"architecture/ecs/#rds-postgresql","title":"RDS PostgreSQL","text":"<p>Base de donn\u00e9es relationnelle PostgreSQL h\u00e9berg\u00e9e sur RDS dans un subnet priv\u00e9. Elle stocke : - Table <code>runs</code> : M\u00e9tadonn\u00e9es des simulations - Table <code>sensor_data</code> : Donn\u00e9es des capteurs avec relations (foreign keys vers runs)</p>"},{"location":"architecture/ecs/#application-load-balancer-alb","title":"Application Load Balancer (ALB)","text":"<p>L'ALB distribue le trafic HTTPS vers les conteneurs ECS. Il g\u00e8re : - Terminaison SSL/TLS avec certificat ACM - Health checks vers <code>/actuator/health</code> - Sticky sessions (optionnel)</p>"},{"location":"architecture/ecs/#monitoring-avec-prometheus","title":"Monitoring avec Prometheus","text":"<p>Un conteneur Prometheus tourne sur ECS et scrape les m\u00e9triques Spring Boot expos\u00e9es sur <code>/actuator/prometheus</code>. Ces m\u00e9triques incluent : - M\u00e9triques JVM (heap, threads, GC) - M\u00e9triques HTTP (requ\u00eates, latence, erreurs) - M\u00e9triques custom (runs actifs, donn\u00e9es capteurs)</p>"},{"location":"architecture/ecs/#grafana","title":"Grafana","text":"<p>Un conteneur Grafana interroge Prometheus et affiche des dashboards temps r\u00e9el. Grafana est accessible via un domaine personnalis\u00e9 avec certificat HTTPS.</p>"},{"location":"architecture/ecs/#flux-de-donnees","title":"\ud83d\udd04 Flux de Donn\u00e9es","text":"<ol> <li>Requ\u00eate entrante : Le frontend envoie une requ\u00eate HTTPS vers l'ALB</li> <li>Routage : L'ALB route vers un conteneur ECS disponible</li> <li>Traitement : Spring Boot traite la requ\u00eate et interroge PostgreSQL</li> <li>R\u00e9ponse : Les donn\u00e9es sont retourn\u00e9es au frontend via l'ALB</li> <li>Monitoring : Prometheus scrape les m\u00e9triques toutes les 15 secondes</li> </ol>"},{"location":"architecture/ecs/#couts","title":"\ud83d\udcb0 Co\u00fbts","text":"Ressource Configuration Co\u00fbt mensuel Fargate (Spring Boot) 1 task, 0.5 vCPU, 1 GB ~$30 RDS PostgreSQL db.t3.micro ~$15 Application Load Balancer Standard ~$16 Fargate (Prometheus) 1 task, 0.25 vCPU, 0.5 GB ~$15 Fargate (Grafana) 1 task, 0.25 vCPU, 0.5 GB ~$15 Total ~$90/mois"},{"location":"architecture/ecs/#deploiement","title":"\ud83d\ude80 D\u00e9ploiement","text":"<pre><code>cd infra/envs/dev\nterraform init\nterraform apply\n</code></pre> <p>Les ressources sont cr\u00e9\u00e9es dans l'ordre suivant : 1. VPC et subnets (publics/priv\u00e9s) 2. Security Groups 3. RDS PostgreSQL 4. ECS Cluster 5. ALB 6. ECS Services (Spring Boot, Prometheus, Grafana)</p> <p>Temps total : ~15 minutes</p>"},{"location":"architecture/ecs/#securite","title":"\ud83d\udd10 S\u00e9curit\u00e9","text":"<ul> <li>VPC : R\u00e9seau isol\u00e9 avec subnets publics (ALB) et priv\u00e9s (ECS, RDS)</li> <li>Security Groups : R\u00e8gles strictes entre composants</li> <li>RDS : Pas d'acc\u00e8s public, uniquement depuis ECS</li> <li>Secrets : Mot de passe BDD stock\u00e9 dans AWS Secrets Manager</li> <li>HTTPS : Certificat ACM sur l'ALB</li> </ul>"},{"location":"architecture/ecs/#avantages","title":"\u26a1 Avantages","text":"<ul> <li>Latence constante : Pas de cold start</li> <li>Connexions persistantes : Pool de connexions vers PostgreSQL</li> <li>Debugging facile : Logs structur\u00e9s dans CloudWatch</li> <li>\u00c9cosyst\u00e8me Java : Librairies Spring Boot \u00e9prouv\u00e9es</li> </ul>"},{"location":"architecture/ecs/#inconvenients","title":"\u26a0\ufe0f Inconv\u00e9nients","text":"<ul> <li>Co\u00fbt fixe : ~$90/mois m\u00eame sans trafic</li> <li>Scaling manuel : N\u00e9cessite configuration auto-scaling</li> <li>Gestion infrastructure : Plus complexe que Serverless</li> </ul>"},{"location":"architecture/overview/","title":"Vue d'ensemble Architecture","text":""},{"location":"architecture/overview/#principe-du-projet","title":"\ud83c\udfaf Principe du Projet","text":"<p>L'infrastructure IoT Playground permet de d\u00e9ployer deux backends distincts pour la m\u00eame application frontend. L'utilisateur peut choisir dans l'interface web quel backend utiliser (ECS ou Serverless), permettant ainsi une comparaison directe des deux approches.</p>"},{"location":"architecture/overview/#backend-ecs-architecture-traditionnelle","title":"Backend ECS (Architecture Traditionnelle)","text":"<p>L'application Spring Boot tourne sur ECS Fargate avec une base de donn\u00e9es PostgreSQL h\u00e9berg\u00e9e sur RDS. Les m\u00e9triques sont expos\u00e9es via un endpoint Prometheus et visualis\u00e9es dans Grafana. Cette architecture est toujours active (always-on) ce qui garantit une latence constante mais implique des co\u00fbts fixes.</p> <p>Composants : VPC priv\u00e9, ECS Cluster, RDS PostgreSQL, ALB, Prometheus, Grafana</p>"},{"location":"architecture/overview/#backend-serverless-architecture-moderne","title":"Backend Serverless (Architecture Moderne)","text":"<p>Les APIs sont impl\u00e9ment\u00e9es en Lambda Python avec stockage dans DynamoDB. Les logs et m\u00e9triques sont envoy\u00e9s vers CloudWatch et visualis\u00e9s dans Grafana. Cette architecture est on-demand : les Lambdas ne s'ex\u00e9cutent que lors des requ\u00eates, ce qui r\u00e9duit drastiquement les co\u00fbts pour les charges l\u00e9g\u00e8res.</p> <p>Composants : Lambda Functions, DynamoDB, API Gateway, CloudWatch Logs, Grafana (optionnel)</p>"},{"location":"architecture/overview/#infrastructure-partagee","title":"\ud83c\udfd7\ufe0f Infrastructure Partag\u00e9e","text":"<p>Les deux architectures partagent certains composants communs :</p>"},{"location":"architecture/overview/#dns-et-certificats","title":"DNS et Certificats","text":"<ul> <li>Route53 g\u00e8re le domaine <code>sentori-studio.com</code></li> <li>ACM (AWS Certificate Manager) fournit les certificats HTTPS pour chaque sous-domaine</li> <li>Chaque architecture a son propre domaine personnalis\u00e9 pour isoler les environnements</li> </ul>"},{"location":"architecture/overview/#etat-terraform","title":"\u00c9tat Terraform","text":"<ul> <li>S3 Bucket stocke l'\u00e9tat Terraform de mani\u00e8re centralis\u00e9e</li> <li>DynamoDB Lock Table \u00e9vite les modifications concurrentes</li> <li>Chaque environnement (<code>dev</code>, <code>serverless-dev</code>) a sa propre cl\u00e9 d'\u00e9tat</li> </ul>"},{"location":"architecture/overview/#flux-de-donnees","title":"\ud83d\udcca Flux de Donn\u00e9es","text":""},{"location":"architecture/overview/#mode-ecs-flux-typique","title":"Mode ECS - Flux Typique","text":"<ol> <li>D\u00e9marrage simulation : Le frontend envoie <code>POST /api/runs/start</code> \u00e0 l'ALB qui route vers le conteneur Spring Boot</li> <li>Stockage : Spring Boot ins\u00e8re le run dans PostgreSQL et g\u00e9n\u00e8re un UUID</li> <li>Ingestion continue : Le frontend envoie les donn\u00e9es capteur via <code>POST /api/sensors/data</code> toutes les N secondes</li> <li>Monitoring : Prometheus scrape les m\u00e9triques expos\u00e9es par Spring Boot (<code>/actuator/prometheus</code>)</li> <li>Visualisation : Grafana query Prometheus et affiche les graphiques en temps r\u00e9el</li> </ol>"},{"location":"architecture/overview/#mode-serverless-flux-typique","title":"Mode Serverless - Flux Typique","text":"<ol> <li>D\u00e9marrage simulation : Le frontend envoie <code>POST /api/runs/start</code> \u00e0 API Gateway qui invoque Lambda Run API</li> <li>Stockage : La Lambda \u00e9crit dans DynamoDB (table Runs) et log les m\u00e9triques dans CloudWatch</li> <li>Ingestion continue : Chaque <code>POST /api/sensors/data</code> invoque Lambda Sensor API qui \u00e9crit dans DynamoDB (table SensorData)</li> <li>Monitoring : Les m\u00e9triques custom sont logg\u00e9es dans CloudWatch Logs</li> <li>Visualisation : Grafana query CloudWatch Logs avec le plugin Athena et affiche les graphiques</li> </ol>"},{"location":"architecture/overview/#securite","title":"\ud83d\udd10 S\u00e9curit\u00e9","text":""},{"location":"architecture/overview/#authentification","title":"Authentification","text":"<p>Actuellement, l'authentification est g\u00e9r\u00e9e via un simple header HTTP <code>X-User</code> qui identifie l'utilisateur. Ce m\u00e9canisme simple permet de s\u00e9parer les simulations par utilisateur sans n\u00e9cessiter un syst\u00e8me d'authentification complet (JWT, OAuth).</p>"},{"location":"architecture/overview/#reseau","title":"R\u00e9seau","text":"<ul> <li>VPC priv\u00e9 : Les bases de donn\u00e9es (RDS, ECS tasks) sont dans des subnets priv\u00e9s</li> <li>Security Groups : R\u00e8gles de pare-feu strictes limitant l'acc\u00e8s inter-services</li> <li>Public Subnets : Uniquement les ALB et NAT Gateways sont expos\u00e9s publiquement</li> </ul>"},{"location":"architecture/overview/#chiffrement","title":"Chiffrement","text":"<ul> <li>HTTPS : Tous les endpoints utilisent des certificats ACM</li> <li>Encryption at Rest : DynamoDB et RDS chiffrent les donn\u00e9es au repos</li> <li>Encryption in Transit : TLS 1.2+ obligatoire sur tous les endpoints</li> </ul>"},{"location":"architecture/overview/#environnements","title":"\ud83c\udf9b\ufe0f Environnements","text":"<p>Le projet d\u00e9finit plusieurs environnements Terraform isol\u00e9s :</p> <ul> <li><code>dev/</code> : Architecture ECS compl\u00e8te (Spring Boot + PostgreSQL)</li> <li><code>serverless-dev/</code> : Architecture Serverless (Lambda + DynamoDB)</li> <li><code>cdn-dev/</code> : H\u00e9bergement frontend via CloudFront (futur)</li> </ul> <p>Chaque environnement a son propre \u00e9tat Terraform, permettant de d\u00e9ployer/d\u00e9truire les ressources ind\u00e9pendamment.</p>"},{"location":"architecture/serverless/","title":"Architecture Serverless","text":""},{"location":"architecture/serverless/#vue-densemble","title":"\ud83c\udfaf Vue d'ensemble","text":"<p>L'architecture Serverless remplace compl\u00e8tement le backend Spring Boot par des fonctions Lambda Python et la base PostgreSQL par DynamoDB. Cette approche \"sans serveur\" permet de ne payer que pour les requ\u00eates effectu\u00e9es, r\u00e9duisant drastiquement les co\u00fbts pour les applications \u00e0 faible trafic.</p>"},{"location":"architecture/serverless/#composants-principaux","title":"Composants Principaux","text":"<p>API Gateway : Point d'entr\u00e9e HTTPS (<code>api-lambda-iot.sentori-studio.com</code>) qui route les requ\u00eates vers les Lambdas appropri\u00e9es</p> <p>Lambda Functions : Deux fonctions Python 3.11 isol\u00e9es : - <code>lambda_run_api</code> : Gestion des simulations (d\u00e9marrer, finir, lister) - <code>lambda_sensor_api</code> : Ingestion et r\u00e9cup\u00e9ration des donn\u00e9es capteurs</p> <p>DynamoDB : Deux tables NoSQL en mode on-demand : - <code>Runs</code> : Stocke les m\u00e9tadonn\u00e9es des simulations - <code>SensorData</code> : Stocke les mesures des capteurs</p> <p>CloudWatch Logs : Collecte les logs et m\u00e9triques custom des Lambdas</p> <p>Grafana (Optionnel) : Conteneur ECS qui query CloudWatch pour afficher les dashboards</p>"},{"location":"architecture/serverless/#ressources-aws","title":"\ud83d\udccb Ressources AWS","text":""},{"location":"architecture/serverless/#lambda-functions","title":"Lambda Functions","text":"Fonction Runtime M\u00e9moire Timeout Trigger run-api Python 3.11 512 MB 30s API Gateway sensor-api Python 3.11 512 MB 30s API Gateway"},{"location":"architecture/serverless/#dynamodb-tables","title":"DynamoDB Tables","text":"<p>Runs Table <pre><code>Partition Key: id (String, UUID)\nAttributes:\n  - username (String)\n  - status (String: RUNNING, COMPLETED, FAILED, INTERRUPTED)\n  - startedAt (String, ISO 8601)\n  - finishedAt (String, ISO 8601, optional)\n  - duration (Number, seconds)\n  - interval (Number, seconds)\n  - params (Map)\n  - grafanaUrl (String)\n</code></pre></p> <p>SensorData Table <pre><code>Partition Key: id (String, UUID)\nSort Key: timestamp (String, ISO 8601)\nAttributes:\n  - runId (String, UUID)\n  - username (String)\n  - sensorId (String)\n  - temperature (Number)\n  - humidity (Number, optional)\n  - pressure (Number, optional)\n</code></pre></p>"},{"location":"architecture/serverless/#flux-api","title":"\ud83d\udd04 Flux API","text":""},{"location":"architecture/serverless/#demarrer-une-simulation","title":"D\u00e9marrer une Simulation","text":"<ol> <li>Frontend envoie <code>POST /api/runs/start</code> avec <code>{duration, interval}</code></li> <li>API Gateway invoque <code>lambda_run_api</code></li> <li>Lambda v\u00e9rifie la limite (max 5 simulations concurrentes globales)</li> <li>Si OK : g\u00e9n\u00e8re un UUID, \u00e9crit dans DynamoDB <code>Runs</code> avec status <code>RUNNING</code></li> <li>Retourne <code>{id, grafanaUrl, ...}</code> au frontend</li> </ol>"},{"location":"architecture/serverless/#ingerer-des-donnees-capteur","title":"Ing\u00e9rer des Donn\u00e9es Capteur","text":"<ol> <li>Frontend envoie <code>POST /api/sensors/data</code> avec <code>{runId, sensorId, temperature}</code></li> <li>API Gateway invoque <code>lambda_sensor_api</code></li> <li>Lambda valide les donn\u00e9es et \u00e9crit dans DynamoDB <code>SensorData</code></li> <li>Logs les m\u00e9triques custom dans CloudWatch</li> <li>Retourne <code>201 Created</code></li> </ol> <p>Le frontend r\u00e9p\u00e8te cette op\u00e9ration toutes les N secondes (selon l'interval configur\u00e9) jusqu'\u00e0 la fin de la simulation.</p>"},{"location":"architecture/serverless/#endpoints-api","title":"\ud83c\udf9b\ufe0f Endpoints API","text":""},{"location":"architecture/serverless/#run-controller","title":"Run Controller","text":"M\u00e9thode Endpoint Description GET <code>/api/runs/can-start</code> V\u00e9rifier limite (5 max global) GET <code>/api/runs/running</code> Lister runs actifs (tous users) POST <code>/api/runs/start</code> D\u00e9marrer simulation POST <code>/api/runs/{id}/finish</code> Terminer simulation POST <code>/api/runs/interrupt-all</code> Interrompre toutes simulations GET <code>/api/runs/{id}</code> D\u00e9tails d'un run GET <code>/api/runs</code> Liste pagin\u00e9e GET <code>/api/runs/all</code> Tous les runs"},{"location":"architecture/serverless/#sensor-controller","title":"Sensor Controller","text":"M\u00e9thode Endpoint Description POST <code>/api/sensors/data</code> Ing\u00e9rer donn\u00e9es capteur GET <code>/api/sensors/data</code> R\u00e9cup\u00e9rer donn\u00e9es"},{"location":"architecture/serverless/#monitoring-cloudwatch","title":"\ud83d\udcca Monitoring CloudWatch","text":"<p>CloudWatch collecte automatiquement plusieurs types de m\u00e9triques :</p>"},{"location":"architecture/serverless/#metriques-lambda-standard","title":"M\u00e9triques Lambda Standard","text":"<ul> <li>Invocations : Nombre d'appels aux fonctions</li> <li>Duration : Temps d'ex\u00e9cution moyen</li> <li>Errors : Taux d'erreur</li> <li>Throttles : Invocations rejet\u00e9es par limite de concurrence</li> </ul>"},{"location":"architecture/serverless/#metriques-custom","title":"M\u00e9triques Custom","text":"<p>Les Lambdas loggent des m\u00e9triques m\u00e9tier sp\u00e9cifiques : - <code>run_started</code> / <code>run_completed</code> : Suivi des simulations - <code>sensor_data_ingested</code> : Volume de donn\u00e9es capteur - <code>temperature_avg</code> : Temp\u00e9rature moyenne par run</p>"},{"location":"architecture/serverless/#metriques-dynamodb","title":"M\u00e9triques DynamoDB","text":"<ul> <li>ConsumedReadCapacity / ConsumedWriteCapacity : Utilisation des tables</li> <li>SuccessfulRequestLatency : Latence des requ\u00eates</li> </ul> <p>Grafana query ces m\u00e9triques via le plugin CloudWatch pour afficher des dashboards temps r\u00e9el.</p>"},{"location":"architecture/serverless/#couts","title":"\ud83d\udcb0 Co\u00fbts","text":"<p>Configuration actuelle (serverless-dev)</p> Ressource Co\u00fbt Idle Co\u00fbt Actif (estimation) Lambda (2 fonctions) $0 $0.0000002 / invocation DynamoDB (2 tables, on-demand) $0 $0.25 / million writes API Gateway $0 $3.50 / million requests CloudWatch Logs ~$0.50/mois Variable Grafana ECS ~$40/mois ~$40/mois VPC (NAT, IGW) ~$40/mois ~$40/mois TOTAL ~$80/mois ~$80/mois + usage <p>\u00c9conomie</p> <p>Pour r\u00e9duire les co\u00fbts, d\u00e9truire Grafana quand non utilis\u00e9 : <pre><code>Component: grafana\nAction: destroy\n</code></pre> \u2192 Co\u00fbt idle : ~$1/mois (CloudWatch Logs uniquement)</p>"},{"location":"architecture/serverless/#securite","title":"\ud83d\udd10 S\u00e9curit\u00e9","text":""},{"location":"architecture/serverless/#api-gateway","title":"API Gateway","text":"<ul> <li>HTTPS obligatoire : Certificat ACM wildcard pour <code>*.sentori-studio.com</code></li> <li>Custom Domain : Domaine personnalis\u00e9 avec Route53</li> <li>CORS configur\u00e9 : Headers autoris\u00e9s pour le frontend Angular</li> </ul>"},{"location":"architecture/serverless/#lambda","title":"Lambda","text":"<ul> <li>IAM Execution Role : Permissions minimales (lecture/\u00e9criture DynamoDB, logs CloudWatch)</li> <li>Environment Variables : Configuration inject\u00e9e au runtime (tables DynamoDB, r\u00e9gion)</li> <li>Pas de VPC : Les Lambdas sont publiques pour r\u00e9duire les co\u00fbts (pas de NAT Gateway)</li> </ul>"},{"location":"architecture/serverless/#dynamodb","title":"DynamoDB","text":"<ul> <li>Encryption at Rest : Chiffrement automatique avec cl\u00e9s AWS</li> <li>IAM Permissions : Acc\u00e8s restreint aux Lambdas uniquement</li> </ul>"},{"location":"architecture/serverless/#deploiement","title":"\ud83d\ude80 D\u00e9ploiement","text":"<p>Le d\u00e9ploiement est g\u00e9r\u00e9 via GitHub Actions avec un workflow unifi\u00e9 (<code>deploy-serverless-unified.yml</code>) qui permet de d\u00e9ployer :</p> <ul> <li>Lambdas uniquement : DynamoDB + Lambda Functions + API Gateway (~5 min)</li> <li>Grafana uniquement : VPC + ECS + ALB (~10 min)</li> <li>Full : Tout l'environnement serverless (~15 min)</li> </ul> <p>Les ressources sont cr\u00e9\u00e9es avec Terraform en utilisant des targets pour d\u00e9ployer/d\u00e9truire de mani\u00e8re granulaire et ind\u00e9pendante.</p>"},{"location":"guide/quickstart/","title":"D\u00e9marrage Rapide","text":""},{"location":"guide/quickstart/#installation","title":"\ud83d\ude80 Installation","text":""},{"location":"guide/quickstart/#prerequis","title":"Pr\u00e9requis","text":"<ul> <li>AWS CLI configur\u00e9</li> <li>Terraform &gt;= 1.6.0</li> <li>Acc\u00e8s GitHub Actions (pour CI/CD)</li> <li>Compte AWS avec permissions IAM suffisantes</li> </ul>"},{"location":"guide/quickstart/#configuration-aws-cli","title":"Configuration AWS CLI","text":"<pre><code>aws configure\n# AWS Access Key ID: VOTRE_ACCESS_KEY\n# AWS Secret Access Key: VOTRE_SECRET_KEY\n# Default region: eu-west-3\n# Default output format: json\n</code></pre>"},{"location":"guide/quickstart/#deploiement-serverless-recommande","title":"\ud83c\udfaf D\u00e9ploiement Serverless (Recommand\u00e9)","text":""},{"location":"guide/quickstart/#etape-1-deployer-les-lambdas","title":"\u00c9tape 1 : D\u00e9ployer les Lambdas","text":"GitHub ActionsLocal (Terraform) <ol> <li>Aller dans Actions \u2192 Deploy Serverless (Unified)</li> <li>Cliquer sur Run workflow</li> <li>Configurer :<ul> <li>Component: <code>lambdas</code></li> <li>Action: <code>apply</code></li> </ul> </li> <li>Attendre ~5 minutes</li> </ol> <pre><code>cd infra/envs/serverless-dev\n\n# Initialiser\nterraform init\n\n# Plan\nterraform plan \\\n  -target=module.acm_lambda_api \\\n  -target=module.dynamodb_tables \\\n  -target=module.lambda_run_api \\\n  -target=module.lambda_sensor_api \\\n  -target=module.api_gateway_lambda_iot\n\n# Apply\nterraform apply \\\n  -target=module.acm_lambda_api \\\n  -target=module.dynamodb_tables \\\n  -target=module.lambda_run_api \\\n  -target=module.lambda_sensor_api \\\n  -target=module.api_gateway_lambda_iot\n</code></pre>"},{"location":"guide/quickstart/#etape-2-recuperer-lurl-api","title":"\u00c9tape 2 : R\u00e9cup\u00e9rer l'URL API","text":"<pre><code>cd infra/envs/serverless-dev\nterraform output api_gateway_url\n# https://api-lambda-iot.sentori-studio.com\n</code></pre>"},{"location":"guide/quickstart/#etape-3-tester-lapi","title":"\u00c9tape 3 : Tester l'API","text":"<pre><code># Can start ?\ncurl https://api-lambda-iot.sentori-studio.com/api/runs/can-start\n\n# D\u00e9marrer une simulation\ncurl -X POST https://api-lambda-iot.sentori-studio.com/api/runs/start \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-User: test-user\" \\\n  -d '{\"duration\": 60, \"interval\": 5}'\n\n# Lister les runs\ncurl https://api-lambda-iot.sentori-studio.com/api/runs\n</code></pre>"},{"location":"guide/quickstart/#etape-4-deployer-grafana-optionnel","title":"\u00c9tape 4 : D\u00e9ployer Grafana (Optionnel)","text":"GitHub ActionsLocal <ol> <li>Actions \u2192 Deploy Serverless (Unified)</li> <li>Configurer :<ul> <li>Component: <code>grafana</code></li> <li>Action: <code>apply</code></li> </ul> </li> <li>Attendre ~10 minutes (VPC + ECS)</li> </ol> <pre><code>terraform apply \\\n  -target=module.acm_grafana \\\n  -target=module.vpc_serverless \\\n  -target=module.ecs_cluster_serverless \\\n  -target=aws_iam_role.grafana_cloudwatch \\\n  -target=aws_iam_role_policy.grafana_cloudwatch \\\n  -target=module.grafana_serverless\n</code></pre>"},{"location":"guide/quickstart/#etape-5-acceder-a-grafana","title":"\u00c9tape 5 : Acc\u00e9der \u00e0 Grafana","text":"<pre><code># R\u00e9cup\u00e9rer l'URL\nterraform output grafana_url\n# https://grafana-lambda-iot.sentori-studio.com\n</code></pre> <p>Ouvrir dans le navigateur \u2192 Dashboard d\u00e9j\u00e0 configur\u00e9 avec CloudWatch datasource ! \ud83c\udf89</p>"},{"location":"guide/quickstart/#ressources-deployees","title":"\ud83d\udcca Ressources D\u00e9ploy\u00e9es","text":"<p>Obligatoires (Lambdas) : API Gateway, Lambda Run API, Lambda Sensor API, DynamoDB (2 tables), CloudWatch Logs</p> <p>Optionnelles (Grafana) : VPC, ECS Cluster, ALB, Grafana Container</p> <p>Le d\u00e9ploiement des Lambdas suffit pour avoir une API fonctionnelle. Grafana n'est n\u00e9cessaire que pour la visualisation.</p>"},{"location":"guide/quickstart/#nettoyage","title":"\ud83e\uddf9 Nettoyage","text":""},{"location":"guide/quickstart/#detruire-grafana-uniquement","title":"D\u00e9truire Grafana uniquement","text":"<pre><code># GitHub Actions\nComponent: grafana\nAction: destroy\nCONFIRM_DESTROY: DESTROY\n</code></pre>"},{"location":"guide/quickstart/#detruire-tout","title":"D\u00e9truire tout","text":"<pre><code># GitHub Actions \u2192 Destroy Serverless\nComponent: full\nAction: destroy\nCONFIRM_DESTROY: DESTROY\nDESTROY_BACKEND: yes  # Supprimer aussi S3 + DynamoDB backend\n</code></pre>"},{"location":"guide/quickstart/#temps-de-deploiement","title":"\u23f1\ufe0f Temps de D\u00e9ploiement","text":"Composant Temps Co\u00fbt apr\u00e8s d\u00e9ploiement Lambdas ~5 min ~$1/mois Grafana ~10 min +$80/mois Full ~15 min ~$81/mois"},{"location":"guide/quickstart/#prochaines-etapes","title":"\ud83c\udfaf Prochaines \u00c9tapes","text":"<ul> <li>Configuration Grafana</li> <li>Gestion des simulations</li> <li>API Reference</li> </ul>"}]}