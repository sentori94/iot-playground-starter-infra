{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"IoT Playground Infrastructure","text":""},{"location":"#but-du-projet","title":"\ud83c\udfaf But du Projet","text":"<p>Ce projet est une plateforme de d\u00e9monstration con\u00e7ue pour comparer deux approches d'architecture cloud sur AWS dans un contexte IoT (Internet of Things). L'objectif est de permettre \u00e0 des utilisateurs de simuler des capteurs IoT qui g\u00e9n\u00e8rent des donn\u00e9es de temp\u00e9rature en temps r\u00e9el, tout en mesurant les diff\u00e9rences de co\u00fbts, performances et complexit\u00e9 entre deux architectures modernes.</p>"},{"location":"#contexte-pedagogique","title":"Contexte P\u00e9dagogique","text":"<p>L'application permet de : - D\u00e9marrer des simulations de capteurs IoT (runs) avec une dur\u00e9e et un intervalle configurables - Ing\u00e9rer des donn\u00e9es de capteurs (temp\u00e9rature, humidit\u00e9, pression) en temps r\u00e9el - Visualiser les m\u00e9triques via des dashboards Grafana - Comparer les deux architectures c\u00f4te \u00e0 c\u00f4te depuis une interface frontend unique</p>"},{"location":"#pourquoi-deux-architectures","title":"Pourquoi Deux Architectures ?","text":"<p>Le projet impl\u00e9mente deux backends distincts pour r\u00e9pondre \u00e0 la question : \"Quelle architecture AWS choisir pour une application IoT ?\"</p> <ol> <li> <p>Architecture ECS (Classique) : Approche traditionnelle avec conteneurs Docker, base de donn\u00e9es relationnelle et monitoring Prometheus. Adapt\u00e9e pour des charges constantes et pr\u00e9visibles.</p> </li> <li> <p>Architecture Serverless : Approche moderne avec Lambda, DynamoDB et CloudWatch. Optimis\u00e9e pour des charges variables avec un mod\u00e8le de co\u00fbts pay-per-use.</p> </li> </ol> <p>Le frontend Angular offre un onglet de s\u00e9lection permettant de basculer entre les deux modes et de comparer l'exp\u00e9rience utilisateur.</p> <pre><code>graph TB\n    subgraph \"Frontend\"\n        A[Angular App]\n    end\n\n    subgraph \"Architecture ECS\"\n        B[ALB]\n        C[ECS Fargate&lt;br/&gt;Spring Boot]\n        D[(RDS PostgreSQL)]\n    end\n\n    subgraph \"Architecture Serverless\"\n        E[API Gateway]\n        F[Lambda Functions]\n        G[(DynamoDB)]\n    end\n\n    A --&gt;|Mode ECS| B\n    B --&gt; C\n    C --&gt; D\n\n    A --&gt;|Mode Serverless| E\n    E --&gt; F\n    F --&gt; G\n\n    style C fill:#fff3e0\n    style F fill:#e8f5e9</code></pre>"},{"location":"#services-aws-utilises","title":"\u2601\ufe0f Services AWS Utilis\u00e9s","text":"Service Usage Architecture ECS Fargate Ex\u00e9cution conteneurs sans serveur ECS RDS PostgreSQL Base de donn\u00e9es relationnelle ECS Lambda Fonctions serverless (Python 3.11) Serverless DynamoDB Base de donn\u00e9es NoSQL Serverless API Gateway Point d'entr\u00e9e REST API Serverless ALB Load balancing HTTPS ECS + Grafana CloudWatch Logs et m\u00e9triques Serverless Route53 DNS et domaines personnalis\u00e9s Les deux ACM Certificats SSL/TLS Les deux VPC R\u00e9seau isol\u00e9 Les deux S3 \u00c9tat Terraform Les deux ECR Registry images Docker ECS"},{"location":"#structure-du-projet","title":"\ud83c\udfd7\ufe0f Structure du Projet","text":"<p>Le projet est organis\u00e9 en modules Terraform r\u00e9utilisables permettant de d\u00e9ployer facilement l'une ou l'autre architecture :</p>"},{"location":"#organisation-des-environnements","title":"Organisation des Environnements","text":"<ul> <li><code>infra/envs/dev/</code> : Configuration compl\u00e8te pour l'architecture ECS avec Spring Boot, RDS PostgreSQL, Prometheus et Grafana</li> <li><code>infra/envs/serverless-dev/</code> : Configuration pour l'architecture Serverless avec Lambda Python, DynamoDB et CloudWatch</li> <li><code>infra/modules/</code> : Modules Terraform partag\u00e9s (r\u00e9seau, base de donn\u00e9es, compute, monitoring)</li> </ul>"},{"location":"#deploiement-avec-github-actions","title":"D\u00e9ploiement avec GitHub Actions","text":"<p>Les workflows CI/CD sont configur\u00e9s pour d\u00e9ployer automatiquement : - Les Lambdas et l'API Gateway via <code>deploy-serverless-unified.yml</code> - L'infrastructure Grafana optionnelle (ECS + VPC) de mani\u00e8re ind\u00e9pendante - Destruction cibl\u00e9e des ressources avec <code>destroy-serverless.yml</code></p>"},{"location":"#domaines-personnalises","title":"Domaines Personnalis\u00e9s","text":"<ul> <li>Frontend : <code>https://app-iot.sentori-studio.com</code></li> <li>API Serverless : <code>https://api-lambda-iot.sentori-studio.com</code></li> <li>Grafana Serverless : <code>https://grafana-lambda-iot.sentori-studio.com</code></li> </ul>"},{"location":"#comparaison-des-architectures","title":"\ud83d\udcca Comparaison des Architectures","text":"Crit\u00e8re ECS Classic Serverless Langage Java (Spring Boot) Python 3.11 Base de donn\u00e9es PostgreSQL (RDS) DynamoDB Co\u00fbt (idle) ~$80/mois ~$1/mois Co\u00fbt (actif) ~$80/mois (fixe) Variable selon usage Scalabilit\u00e9 Auto-scaling ECS Auto-scaling Lambda Cold Start Aucun ~1-2s Monitoring Prometheus CloudWatch Logs"},{"location":"#cas-dusage-recommandes","title":"Cas d'Usage Recommand\u00e9s","text":"<p>ECS : Trafic constant et pr\u00e9visible, latence critique, connexions persistantes Serverless : Trafic sporadique, pics de charge, budget limit\u00e9, pay-per-use</p>"},{"location":"#organisation-du-projet","title":"\ud83d\udcc1 Organisation du Projet","text":"<p>Le projet est structur\u00e9 en environnements Terraform s\u00e9par\u00e9s :</p> <ul> <li><code>infra/envs/dev/</code> : Architecture ECS compl\u00e8te (Spring Boot + PostgreSQL)</li> <li><code>infra/envs/serverless-dev/</code> : Architecture Serverless (Lambda + DynamoDB)  </li> <li><code>infra/modules/</code> : Modules Terraform r\u00e9utilisables (r\u00e9seau, compute, BDD, monitoring)</li> <li><code>.github/workflows/</code> : Workflows CI/CD pour d\u00e9ploiement automatis\u00e9</li> </ul> <p>Les workflows GitHub Actions permettent de d\u00e9ployer chaque composant ind\u00e9pendamment (lambdas, grafana) ou ensemble (full).</p>"},{"location":"#navigation","title":"\ud83d\udd17 Navigation","text":"<ul> <li>Architecture : ECS | Serverless | Comparaison</li> <li>D\u00e9ploiement : Infrastructure ECS &amp; Serverless</li> <li>Guide utilisateur : D\u00e9marrage rapide &amp; parcours m\u00e9tier</li> <li>API : Run Controller | Sensor Controller</li> </ul>"},{"location":"api/run-controller/","title":"API Run Controller","text":"<p>Gestion du cycle de vie des simulations (runs).</p>"},{"location":"api/run-controller/#endpoints","title":"\ud83d\udccb Endpoints","text":""},{"location":"api/run-controller/#get-apirunscan-start","title":"GET <code>/api/runs/can-start</code>","text":"<p>V\u00e9rifie si on peut d\u00e9marrer une nouvelle simulation.</p> <p>Headers <pre><code>(aucun header requis)\n</code></pre></p> <p>Response 200 <pre><code>{\n  \"canStart\": true,\n  \"currentRunning\": 2,\n  \"maxAllowed\": 5,\n  \"available\": 3\n}\n</code></pre></p>"},{"location":"api/run-controller/#post-apirunsstart","title":"POST <code>/api/runs/start</code>","text":"<p>D\u00e9marre une nouvelle simulation.</p> <p>Headers <pre><code>Content-Type: application/json\nX-User: username\n</code></pre></p> <p>Body <pre><code>{\n  \"duration\": 60,\n  \"interval\": 5\n}\n</code></pre></p> <p>Response 201 <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"username\": \"test-user\",\n  \"status\": \"RUNNING\",\n  \"startedAt\": \"2025-01-15T10:30:00Z\",\n  \"duration\": 60,\n  \"interval\": 5,\n  \"params\": {\n    \"duration\": 60,\n    \"interval\": 5\n  },\n  \"grafanaUrl\": \"https://grafana-lambda-iot.sentori-studio.com/d/...\"\n}\n</code></pre></p> <p>Response 400 (limite atteinte) <pre><code>{\n  \"error\": \"Maximum concurrent runs reached\",\n  \"currentRunning\": 5,\n  \"maxAllowed\": 5\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apirunsrunning","title":"GET <code>/api/runs/running</code>","text":"<p>Liste tous les runs en cours (tous utilisateurs).</p> <p>Response 200 <pre><code>[\n  {\n    \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"username\": \"user1\",\n    \"status\": \"RUNNING\",\n    \"startedAt\": \"2025-01-15T10:30:00Z\",\n    \"duration\": 60,\n    \"interval\": 5\n  },\n  {\n    \"id\": \"660e8400-e29b-41d4-a716-446655440001\",\n    \"username\": \"user2\",\n    \"status\": \"RUNNING\",\n    \"startedAt\": \"2025-01-15T10:32:00Z\",\n    \"duration\": 120,\n    \"interval\": 10\n  }\n]\n</code></pre></p>"},{"location":"api/run-controller/#post-apirunsidfinish","title":"POST <code>/api/runs/{id}/finish</code>","text":"<p>Termine un run en cours.</p> <p>Path Parameters - <code>id</code> : UUID du run</p> <p>Headers <pre><code>Content-Type: application/json\n</code></pre></p> <p>Body (optionnel) <pre><code>{\n  \"errorMessage\": \"Simulation interrupted by user\"\n}\n</code></pre></p> <p>Response 200 <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"username\": \"test-user\",\n  \"status\": \"COMPLETED\",\n  \"startedAt\": \"2025-01-15T10:30:00Z\",\n  \"finishedAt\": \"2025-01-15T10:31:00Z\",\n  \"duration\": 60,\n  \"interval\": 5\n}\n</code></pre></p> <p>Response 404 <pre><code>{\n  \"error\": \"Run not found\"\n}\n</code></pre></p> <p>Response 400 <pre><code>{\n  \"error\": \"Run is not running\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#post-apirunsinterrupt-all","title":"POST <code>/api/runs/interrupt-all</code>","text":"<p>Interrompt toutes les simulations en cours (tous utilisateurs).</p> <p>Response 200 <pre><code>{\n  \"interrupted\": 3,\n  \"message\": \"3 simulation(s) interrupted\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apirunsid","title":"GET <code>/api/runs/{id}</code>","text":"<p>D\u00e9tails d'un run sp\u00e9cifique.</p> <p>Path Parameters - <code>id</code> : UUID du run</p> <p>Response 200 <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"username\": \"test-user\",\n  \"status\": \"COMPLETED\",\n  \"startedAt\": \"2025-01-15T10:30:00Z\",\n  \"finishedAt\": \"2025-01-15T10:31:00Z\",\n  \"duration\": 60,\n  \"interval\": 5,\n  \"params\": {\n    \"duration\": 60,\n    \"interval\": 5\n  },\n  \"grafanaUrl\": \"https://grafana-lambda-iot.sentori-studio.com/d/...\"\n}\n</code></pre></p> <p>Response 404 <pre><code>{\n  \"error\": \"Run not found\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apiruns","title":"GET <code>/api/runs</code>","text":"<p>Liste pagin\u00e9e de tous les runs.</p> <p>Query Parameters - <code>limit</code> (optional) : Nombre d'items par page (d\u00e9faut: 20) - <code>lastKey</code> (optional) : Cl\u00e9 de pagination (base64)</p> <p>Response 200 <pre><code>{\n  \"items\": [\n    {\n      \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"username\": \"test-user\",\n      \"status\": \"COMPLETED\",\n      \"startedAt\": \"2025-01-15T10:30:00Z\",\n      \"finishedAt\": \"2025-01-15T10:31:00Z\"\n    }\n  ],\n  \"count\": 20,\n  \"nextKey\": \"eyJpZCI6ICIuLi4ifQ==\"\n}\n</code></pre></p>"},{"location":"api/run-controller/#get-apirunsall","title":"GET <code>/api/runs/all</code>","text":"<p>Tous les runs sans pagination.</p> <p>Response 200 <pre><code>[\n  {\n    \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"username\": \"test-user\",\n    \"status\": \"COMPLETED\",\n    \"startedAt\": \"2025-01-15T10:30:00Z\"\n  },\n  ...\n]\n</code></pre></p>"},{"location":"api/run-controller/#etats-du-run","title":"\ud83d\udcca \u00c9tats du Run","text":"<p>Un run peut avoir 4 \u00e9tats :</p> <ul> <li>RUNNING : Simulation en cours</li> <li>COMPLETED : Simulation termin\u00e9e avec succ\u00e8s</li> <li>FAILED : Simulation termin\u00e9e avec erreur</li> <li>INTERRUPTED : Simulation interrompue manuellement</li> </ul> <p>Transitions : <code>RUNNING</code> \u2192 <code>COMPLETED</code> / <code>FAILED</code> / <code>INTERRUPTED</code> (\u00e9tats finaux)</p>"},{"location":"api/run-controller/#authentification","title":"\ud83d\udd10 Authentification","text":"<p>Actuellement : Header <code>X-User</code></p> <pre><code>curl -H \"X-User: mon-username\" \\\n  https://api-lambda-iot.sentori-studio.com/api/runs/running\n</code></pre>"},{"location":"api/run-controller/#codes-derreur","title":"\ud83d\udea8 Codes d'Erreur","text":"Code Description 200 Success 201 Created 400 Bad Request (limite, validation) 404 Run not found 405 Method not allowed 500 Internal server error"},{"location":"api/run-controller/#liens","title":"\ud83d\udd17 Liens","text":"<ul> <li>Sensor Controller API</li> <li>Guide Simulations</li> </ul>"},{"location":"api/sensor-controller/","title":"API Sensor Controller","text":"<p>Gestion de l'ingestion et r\u00e9cup\u00e9ration des donn\u00e9es de capteurs IoT.</p>"},{"location":"api/sensor-controller/#endpoints","title":"\ud83d\udccb Endpoints","text":""},{"location":"api/sensor-controller/#post-apisensorsdata","title":"POST <code>/api/sensors/data</code>","text":"<p>Ing\u00e8re une mesure de capteur dans le syst\u00e8me.</p> <p>Headers <pre><code>Content-Type: application/json\nX-User: username\nX-Run-Id: run-uuid\n</code></pre></p> <p>Body <pre><code>{\n  \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"sensorId\": \"sensor-001\",\n  \"temperature\": 23.5,\n  \"humidity\": 65.2,\n  \"pressure\": 1013.25\n}\n</code></pre></p> <p>Response 201 <pre><code>{\n  \"id\": \"660e8400-e29b-41d4-a716-446655440001\",\n  \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"sensorId\": \"sensor-001\",\n  \"timestamp\": \"2025-01-15T10:30:05Z\",\n  \"temperature\": 23.5,\n  \"humidity\": 65.2,\n  \"pressure\": 1013.25\n}\n</code></pre></p> <p>Response 400 (validation error) <pre><code>{\n  \"error\": \"Invalid sensor data\",\n  \"details\": \"temperature must be a number\"\n}\n</code></pre></p> <p>Response 404 (run not found) <pre><code>{\n  \"error\": \"Run not found\"\n}\n</code></pre></p>"},{"location":"api/sensor-controller/#get-apisensorsdata","title":"GET <code>/api/sensors/data</code>","text":"<p>R\u00e9cup\u00e8re les donn\u00e9es de capteurs filtr\u00e9es.</p> <p>Query Parameters - <code>runId</code> (optional) : UUID du run - <code>sensorId</code> (optional) : ID du capteur - <code>startDate</code> (optional) : Date de d\u00e9but (ISO 8601) - <code>endDate</code> (optional) : Date de fin (ISO 8601) - <code>limit</code> (optional) : Nombre max de r\u00e9sultats (d\u00e9faut: 100)</p> <p>Examples <pre><code># Toutes les donn\u00e9es d'un run\nGET /api/sensors/data?runId=550e8400-e29b-41d4-a716-446655440000\n\n# Donn\u00e9es d'un capteur sp\u00e9cifique\nGET /api/sensors/data?sensorId=sensor-001\n\n# Donn\u00e9es dans une p\u00e9riode\nGET /api/sensors/data?startDate=2025-01-15T10:00:00Z&amp;endDate=2025-01-15T11:00:00Z\n</code></pre></p> <p>Response 200 <pre><code>[\n  {\n    \"id\": \"660e8400-e29b-41d4-a716-446655440001\",\n    \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"sensorId\": \"sensor-001\",\n    \"timestamp\": \"2025-01-15T10:30:05Z\",\n    \"temperature\": 23.5,\n    \"humidity\": 65.2,\n    \"pressure\": 1013.25\n  },\n  {\n    \"id\": \"660e8400-e29b-41d4-a716-446655440002\",\n    \"runId\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"sensorId\": \"sensor-001\",\n    \"timestamp\": \"2025-01-15T10:30:10Z\",\n    \"temperature\": 23.7,\n    \"humidity\": 65.0,\n    \"pressure\": 1013.20\n  }\n]\n</code></pre></p>"},{"location":"api/sensor-controller/#format-des-donnees","title":"\ud83d\udcca Format des Donn\u00e9es","text":""},{"location":"api/sensor-controller/#capteur-simple-temperature-uniquement","title":"Capteur Simple (Temp\u00e9rature uniquement)","text":"<pre><code>{\n  \"runId\": \"...\",\n  \"sensorId\": \"temp-sensor-01\",\n  \"temperature\": 23.5\n}\n</code></pre>"},{"location":"api/sensor-controller/#capteur-complet-temperature-humidite-pression","title":"Capteur Complet (Temp\u00e9rature, Humidit\u00e9, Pression)","text":"<pre><code>{\n  \"runId\": \"...\",\n  \"sensorId\": \"multi-sensor-01\",\n  \"temperature\": 23.5,\n  \"humidity\": 65.2,\n  \"pressure\": 1013.25\n}\n</code></pre>"},{"location":"api/sensor-controller/#flux-dingestion-typique","title":"\ud83d\udd04 Flux d'Ingestion Typique","text":"<ol> <li>Frontend d\u00e9marre une simulation via <code>POST /api/runs/start</code></li> <li>R\u00e9cup\u00e8re le <code>runId</code> dans la r\u00e9ponse</li> <li>Toutes les N secondes (interval configur\u00e9) :</li> <li>G\u00e9n\u00e8re des donn\u00e9es de capteur (temp\u00e9rature al\u00e9atoire)</li> <li>Envoie via <code>POST /api/sensors/data</code> avec le <code>runId</code></li> <li>Continue jusqu'\u00e0 la fin de la dur\u00e9e configur\u00e9e</li> <li>Termine la simulation via <code>POST /api/runs/{id}/finish</code></li> </ol>"},{"location":"api/sensor-controller/#authentification","title":"\ud83d\udd10 Authentification","text":"<p>Les headers suivants sont requis : - <code>X-User</code> : Identifiant de l'utilisateur (string) - <code>X-Run-Id</code> : UUID du run associ\u00e9 (optionnel sur GET)</p>"},{"location":"api/sensor-controller/#codes-derreur","title":"\ud83d\udea8 Codes d'Erreur","text":"Code Description 201 Created 200 Success (GET) 400 Bad Request (validation) 404 Run not found 405 Method not allowed 500 Internal server error"},{"location":"api/sensor-controller/#exemples","title":"\ud83d\udca1 Exemples","text":""},{"location":"api/sensor-controller/#exemple-complet-avec-curl","title":"Exemple complet avec cURL","text":"<pre><code># 1. D\u00e9marrer un run\nRUN_ID=$(curl -X POST /api/runs/start \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-User: demo-user\" \\\n  -d '{\"duration\": 60, \"interval\": 5}' | jq -r '.id')\n\n# 2. Ing\u00e9rer des donn\u00e9es\ncurl -X POST /api/sensors/data \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-User: demo-user\" \\\n  -H \"X-Run-Id: $RUN_ID\" \\\n  -d \"{\n    \\\"runId\\\": \\\"$RUN_ID\\\",\n    \\\"sensorId\\\": \\\"temp-sensor-01\\\",\n    \\\"temperature\\\": 23.5\n  }\"\n\n# 3. R\u00e9cup\u00e9rer les donn\u00e9es\ncurl \"/api/sensors/data?runId=$RUN_ID\"\n</code></pre>"},{"location":"api/sensor-controller/#liens","title":"\ud83d\udd17 Liens","text":"<ul> <li>Run Controller API</li> <li>Guide Simulations</li> </ul>"},{"location":"architecture/aws-services/","title":"Services AWS utilis\u00e9s","text":"<p>Cette page r\u00e9sume les principaux services AWS du projet et leur r\u00f4le.</p>"},{"location":"architecture/aws-services/#compute-conteneurs","title":"\ud83e\uddf1 Compute &amp; Conteneurs","text":"<p>ECS Fargate - Sert \u00e0 ex\u00e9cuter les conteneurs :   - Application Spring Boot (mode ECS classique)   - Prometheus   - Grafana (mode ECS, y compris pour le monitoring serverless) - Permet de b\u00e9n\u00e9ficier de conteneurs manag\u00e9s sans g\u00e9rer d\u2019instances EC2.</p> <p>AWS Lambda - Utilis\u00e9 pour le backend Serverless :   - <code>lambda_run_api</code> : gestion des runs (can-start, start, finish, interrupt-all)   - <code>lambda_sensor_api</code> : ingestion des donn\u00e9es capteurs - Facturation \u00e0 l\u2019appel et au temps d\u2019ex\u00e9cution.</p>"},{"location":"architecture/aws-services/#reseau-acces","title":"\ud83c\udf10 R\u00e9seau &amp; Acc\u00e8s","text":"<p>VPC (Virtual Private Cloud) - Fournit un r\u00e9seau isol\u00e9 pour :   - ECS + RDS (mode ECS)   - Grafana serverless (VPC d\u00e9di\u00e9) - S\u00e9pare subnets publics (ALB, NAT) et subnets priv\u00e9s (ECS, RDS, Grafana).</p> <p>Subnets publics / priv\u00e9s - Publics : ressources expos\u00e9es (ALB, NAT Gateway). - Priv\u00e9s : ressources sensibles (ECS tasks, RDS, Grafana).</p> <p>NAT Gateway - Permet aux ressources en subnets priv\u00e9s (ECS, Grafana) de sortir sur Internet (par exemple pour t\u00e9l\u00e9charger des images, plugins, etc.) sans \u00eatre expos\u00e9es directement.</p> <p>Application Load Balancer (ALB) - Point d\u2019entr\u00e9e HTTP/HTTPS de l\u2019architecture ECS et de Grafana serverless. - Fait la terminaison TLS (certificat ACM) et distribue le trafic vers les t\u00e2ches ECS.</p> <p>API Gateway - Point d\u2019entr\u00e9e HTTP/HTTPS pour le backend Serverless. - Route vers les Lambdas avec int\u00e9gration REST. - G\u00e8re les aspects CORS, throttling, monitoring c\u00f4t\u00e9 API.</p>"},{"location":"architecture/aws-services/#stockage-bases-de-donnees","title":"\ud83d\uddc4\ufe0f Stockage &amp; Bases de donn\u00e9es","text":"<p>RDS PostgreSQL - Base de donn\u00e9es relationnelle pour l\u2019architecture ECS. - Stocke les entit\u00e9s classiques : <code>runs</code>, <code>sensor_data</code>, etc.</p> <p>DynamoDB - Base NoSQL pour l\u2019architecture Serverless. - Deux tables principales :   - <code>Runs</code> : m\u00e9tadonn\u00e9es des simulations   - <code>SensorData</code> : mesures des capteurs - Mode on-demand (pay-per-request), parfaitement adapt\u00e9 \u00e0 Lambda.</p> <p>S3 - Utilis\u00e9 pour stocker l\u2019\u00e9tat Terraform (remote backend). - Permet d\u2019avoir un historique centralis\u00e9 des d\u00e9ploiements infra.</p>"},{"location":"architecture/aws-services/#dns-certificats-iam","title":"\ud83d\udd10 DNS, Certificats &amp; IAM","text":"<p>Route53 - G\u00e8re le domaine <code>sentori-studio.com</code> et les sous-domaines :   - <code>app-iot.sentori-studio.com</code> (frontend)   - <code>api-lambda-iot.sentori-studio.com</code> (API Serverless)   - <code>grafana-lambda-iot.sentori-studio.com</code> (Grafana serverless)</p> <p>AWS Certificate Manager (ACM) - Fournit les certificats SSL/TLS pour les sous-domaines du projet. - Int\u00e9gr\u00e9 \u00e0 ALB et API Gateway pour du HTTPS de bout en bout.</p> <p>IAM (Identity and Access Management) - D\u00e9finit les r\u00f4les et policies pour :   - Lambdas (acc\u00e8s DynamoDB, CloudWatch)   - ECS tasks (acc\u00e8s CloudWatch, ECR)   - Terraform (droits de cr\u00e9ation/suppression des ressources)</p>"},{"location":"architecture/aws-services/#observabilite","title":"\ud83d\udcca Observabilit\u00e9","text":"<p>CloudWatch - Collecte les logs des Lambdas et des conteneurs ECS. - Expose des m\u00e9triques (invocations, erreurs, latence, capacit\u00e9 DynamoDB\u2026). - Sert de datasource pour Grafana en mode Serverless.</p> <p>Prometheus - D\u00e9ploy\u00e9 dans le VPC ECS. - Scrape les m\u00e9triques Spring Boot (<code>/actuator/prometheus</code>). - Sert de datasource pour Grafana en mode ECS.</p> <p>Grafana - Unifi\u00e9 pour les deux architectures :   - Datasource Prometheus (ECS)   - Datasource CloudWatch (Serverless) - Affiche des dashboards centr\u00e9s sur le m\u00e9tier : Sensor, User, Run.</p>"},{"location":"architecture/aws-services/#images-artefacts","title":"\ud83d\udce6 Images &amp; Artefacts","text":"<p>ECR (Elastic Container Registry) - Stocke les images Docker :   - Application Spring Boot   - Grafana (image custom pour le mode serverless) - Int\u00e9gr\u00e9 \u00e0 ECS pour le d\u00e9ploiement des t\u00e2ches.</p>"},{"location":"architecture/comparison/","title":"Comparaison ECS vs Serverless","text":""},{"location":"architecture/comparison/#objectif-de-la-comparaison","title":"\ud83c\udfaf Objectif de la Comparaison","text":"<p>Ce projet permet de mesurer concr\u00e8tement les diff\u00e9rences entre une architecture conteneuris\u00e9e (ECS) et une architecture serverless (Lambda) sur AWS. Les deux impl\u00e9mentent exactement la m\u00eame fonctionnalit\u00e9 (simulation de capteurs IoT), permettant une comparaison objective.</p> <pre><code>graph TB\n    subgraph \"Architecture ECS\"\n        A1[Always-On]\n        A2[Conteneurs Docker]\n        A3[PostgreSQL]\n        A4[Co\u00fbt fixe: $90/mois]\n    end\n\n    subgraph \"Architecture Serverless\"\n        B1[On-Demand]\n        B2[Lambda Python]\n        B3[DynamoDB]\n        B4[Co\u00fbt variable: $1-150/mois]\n    end\n\n    subgraph \"Frontend Unique\"\n        C[Angular App]\n    end\n\n    C --&gt;|M\u00eame API| A2\n    C --&gt;|M\u00eame API| B2\n\n    style A2 fill:#fff3e0\n    style B2 fill:#e8f5e9</code></pre>"},{"location":"architecture/comparison/#tableau-comparatif","title":"\ud83d\udcca Tableau Comparatif","text":"Aspect ECS Classic Serverless Lambda Runtime Spring Boot (Java) Python 3.11 Base de donn\u00e9es PostgreSQL (RDS) DynamoDB Compute ECS Fargate (Always-on) Lambda (On-demand) Scaling Auto-scaling ECS Auto-scaling Lambda Cold Start \u274c Aucun \u26a0\ufe0f ~1-2s (first request) Co\u00fbt idle ~$80/mois ~$1/mois (sans Grafana) Co\u00fbt actif ~$80/mois (fixe) Variable selon usage Monitoring Prometheus CloudWatch Logs Grafana Datasource Prometheus Datasource CloudWatch HTTPS \u2705 ALB + ACM \u2705 API Gateway + ACM Authentification Header X-User Header X-User Limite concurrent Configurable ECS 5 runs globaux"},{"location":"architecture/comparison/#cas-dusage-recommandes","title":"\ud83c\udfaf Cas d'Usage Recommand\u00e9s","text":""},{"location":"architecture/comparison/#ecs-classic","title":"ECS Classic","text":"<p>Quand choisir ECS : - Trafic constant et pr\u00e9visible (&gt; 100 req/min en continu) - Besoin de latence ultra-faible (&lt; 50ms) - Applications avec \u00e9tat ou connexions persistantes - Workloads de longue dur\u00e9e (&gt; 15 minutes)</p> <p>Avantages ECS : - \u2705 Pas de cold start - \u2705 Connexions persistantes (BDD, cache) - \u2705 Latence pr\u00e9visible - \u2705 Debugging plus simple (logs structur\u00e9s) - \u2705 \u00c9cosyst\u00e8me Java mature</p> <p>Inconv\u00e9nients ECS : - \u274c Co\u00fbt fixe m\u00eame sans trafic - \u274c Gestion de l'infrastructure - \u274c Scaling moins r\u00e9actif</p>"},{"location":"architecture/comparison/#serverless-lambda","title":"Serverless Lambda","text":"<p>Quand choisir Serverless : - Trafic sporadique ou impr\u00e9visible - Budget limit\u00e9 (pay-per-use) - Pics de charge importants n\u00e9cessitant un scaling rapide - Prototypes ou applications en phase de test</p> <p>Avantages Serverless : - \u2705 Pay-per-use (co\u00fbt = usage r\u00e9el) - \u2705 Scaling automatique infini - \u2705 Pas de gestion serveur - \u2705 DynamoDB tr\u00e8s performant</p> <p>Inconv\u00e9nients Serverless : - \u274c Cold start (~1-2s) - \u274c Timeout max 15 minutes - \u274c Debugging plus complexe - \u274c Vendor lock-in AWS</p>"},{"location":"architecture/comparison/#analyse-couts-detaillee","title":"\ud83d\udcb0 Analyse Co\u00fbts D\u00e9taill\u00e9e","text":""},{"location":"architecture/comparison/#scenario-1000-reqjour","title":"Sc\u00e9nario : 1000 req/jour","text":"ECSServerless Ressource Co\u00fbt mensuel Fargate (1 task, 0.5 vCPU, 1 GB) ~$30 RDS PostgreSQL (db.t3.micro) ~$15 ALB ~$16 Prometheus ECS ~$15 Grafana ECS ~$15 TOTAL ~$90/mois Ressource Co\u00fbt mensuel Lambda (30k invocations) ~$0.01 DynamoDB (on-demand, 30k writes) ~$0.40 API Gateway (30k requests) ~$0.10 CloudWatch Logs (5 GB) ~$2.50 Grafana ECS (si actif) ~$40 VPC (NAT, IGW pour Grafana) ~$40 TOTAL (avec Grafana) ~$83/mois TOTAL (sans Grafana) ~$3/mois"},{"location":"architecture/comparison/#scenario-100k-reqjour","title":"Sc\u00e9nario : 100k req/jour","text":"ECSServerless Ressource Co\u00fbt mensuel Fargate (2 tasks, 1 vCPU, 2 GB) ~$60 RDS PostgreSQL (db.t3.small) ~$30 ALB ~$20 Prometheus ECS ~$15 Grafana ECS ~$15 TOTAL ~$140/mois Ressource Co\u00fbt mensuel Lambda (3M invocations) ~$1.20 DynamoDB (3M writes) ~$40 API Gateway (3M requests) ~$10 CloudWatch Logs (50 GB) ~$25 Grafana ECS ~$40 VPC ~$40 TOTAL ~$156/mois"},{"location":"architecture/comparison/#conclusion-couts","title":"Conclusion Co\u00fbts","text":"<p>Analyse</p> <ul> <li>&lt; 10k req/jour \u2192 Serverless beaucoup moins cher</li> <li>10k - 50k req/jour \u2192 \u00c9quivalent</li> <li>&gt; 100k req/jour \u2192 ECS plus \u00e9conomique</li> </ul>"},{"location":"architecture/comparison/#performance","title":"\u26a1 Performance","text":""},{"location":"architecture/comparison/#latence-observee","title":"Latence Observ\u00e9e","text":"<p>ECS (toujours chaud) : P50 ~50ms, P95 ~100ms, P99 ~150ms Serverless (warm) : P50 ~80ms, P95 ~200ms, P99 ~500ms Serverless (cold start) : P50 ~1500ms, P95 ~2500ms, P99 ~3500ms</p> <p>Le cold start est le principal inconv\u00e9nient du Serverless, mais il ne se produit que sur la premi\u00e8re requ\u00eate ou apr\u00e8s une p\u00e9riode d'inactivit\u00e9.</p>"},{"location":"architecture/comparison/#throughput","title":"Throughput","text":"Architecture Max Throughput Scaling Time ECS ~1000 req/s (2 tasks) 2-3 minutes Serverless ~10000 req/s (1000 lambdas) &lt; 10 secondes"},{"location":"architecture/comparison/#recommandation-pour-ce-projet","title":"\ud83c\udf93 Recommandation pour ce Projet","text":"<p>Approche P\u00e9dagogique</p> <p>Les deux architectures sont d\u00e9ploy\u00e9es pour permettre la comparaison :</p> <ul> <li>ECS : <code>infra/envs/dev/</code></li> <li>Serverless : <code>infra/envs/serverless-dev/</code></li> </ul> <p>\u2192 Choix dans le frontend : \"Mode ECS\" vs \"Mode Serverless\"</p>"},{"location":"architecture/ecs/","title":"Architecture ECS (Classic)","text":""},{"location":"architecture/ecs/#vue-densemble","title":"\ud83c\udfaf Vue d'ensemble","text":"<p>L'architecture ECS repr\u00e9sente l'approche traditionnelle avec des conteneurs Docker qui tournent en permanence sur AWS Fargate. Cette architecture est adapt\u00e9e aux applications n\u00e9cessitant une latence constante et pr\u00e9visible, avec des connexions persistantes vers la base de donn\u00e9es.</p> <pre><code>graph LR\n    FRONTEND[Frontend] --&gt;|HTTPS| ALB[Application&lt;br/&gt;Load Balancer]\n\n    ALB --&gt; ECS[ECS Fargate&lt;br/&gt;Spring Boot]\n\n    ECS --&gt; RDS[(RDS&lt;br/&gt;PostgreSQL)]\n\n    ECS -.expose.-&gt; PROM[Prometheus&lt;br/&gt;ECS]\n\n    PROM --&gt; GRAFANA[Grafana&lt;br/&gt;ECS]\n\n    style ECS fill:#fff3e0\n    style ALB fill:#e1f5ff\n    style GRAFANA fill:#e3f2fd</code></pre>"},{"location":"architecture/ecs/#composants-principaux","title":"\ud83c\udfd7\ufe0f Composants Principaux","text":""},{"location":"architecture/ecs/#services-aws-utilises","title":"Services AWS Utilis\u00e9s","text":"Service Usage Justification ECS Fargate Ex\u00e9cution conteneurs Pas de gestion EC2, scaling facile RDS PostgreSQL Base relationnelle Donn\u00e9es structur\u00e9es, transactions ACID ALB Load balancing Distribution trafic, terminaison SSL ECR Registry Docker Stockage images Spring Boot VPC R\u00e9seau priv\u00e9 Isolation, security groups CloudWatch Logs conteneurs Centralisation logs ECS Route53 DNS custom domain Gestion domaine sentori-studio.com ACM Certificat HTTPS Gratuit, renouvellement auto"},{"location":"architecture/ecs/#ecs-fargate","title":"ECS Fargate","text":"<p>Les conteneurs Spring Boot tournent sur Fargate (serverless containers) sans avoir \u00e0 g\u00e9rer les instances EC2. Chaque t\u00e2che ECS a 0.5 vCPU et 1 GB de m\u00e9moire, suffisant pour l'application IoT Playground.</p>"},{"location":"architecture/ecs/#rds-postgresql","title":"RDS PostgreSQL","text":"<p>Base de donn\u00e9es relationnelle PostgreSQL h\u00e9berg\u00e9e sur RDS dans un subnet priv\u00e9. Elle stocke : - Table <code>runs</code> : M\u00e9tadonn\u00e9es des simulations - Table <code>sensor_data</code> : Donn\u00e9es des capteurs avec relations (foreign keys vers runs)</p>"},{"location":"architecture/ecs/#application-load-balancer-alb","title":"Application Load Balancer (ALB)","text":"<p>L'ALB distribue le trafic HTTPS vers les conteneurs ECS. Il g\u00e8re : - Terminaison SSL/TLS avec certificat ACM - Health checks vers <code>/actuator/health</code> - Sticky sessions (optionnel)</p>"},{"location":"architecture/ecs/#monitoring-avec-prometheus","title":"Monitoring avec Prometheus","text":"<p>Un conteneur Prometheus tourne sur ECS et scrape les m\u00e9triques Spring Boot expos\u00e9es sur <code>/actuator/prometheus</code>. Ces m\u00e9triques incluent : - M\u00e9triques JVM (heap, threads, GC) - M\u00e9triques HTTP (requ\u00eates, latence, erreurs) - M\u00e9triques custom (runs actifs, donn\u00e9es capteurs)</p>"},{"location":"architecture/ecs/#grafana","title":"Grafana","text":"<p>Un conteneur Grafana interroge Prometheus et affiche des dashboards temps r\u00e9el. Grafana est accessible via un domaine personnalis\u00e9 avec certificat HTTPS.</p>"},{"location":"architecture/ecs/#flux-de-donnees","title":"\ud83d\udd04 Flux de Donn\u00e9es","text":"<ol> <li>Requ\u00eate entrante : Le frontend envoie une requ\u00eate HTTPS vers l'ALB</li> <li>Routage : L'ALB route vers un conteneur ECS disponible</li> <li>Traitement : Spring Boot traite la requ\u00eate et interroge PostgreSQL</li> <li>R\u00e9ponse : Les donn\u00e9es sont retourn\u00e9es au frontend via l'ALB</li> <li>Monitoring : Prometheus scrape les m\u00e9triques toutes les 15 secondes</li> </ol>"},{"location":"architecture/ecs/#couts","title":"\ud83d\udcb0 Co\u00fbts","text":"Ressource Configuration Co\u00fbt mensuel Fargate (Spring Boot) 1 task, 0.5 vCPU, 1 GB ~$30 RDS PostgreSQL db.t3.micro ~$15 Application Load Balancer Standard ~$16 Fargate (Prometheus) 1 task, 0.25 vCPU, 0.5 GB ~$15 Fargate (Grafana) 1 task, 0.25 vCPU, 0.5 GB ~$15 Total ~$90/mois"},{"location":"architecture/ecs/#deploiement","title":"\ud83d\ude80 D\u00e9ploiement","text":"<pre><code>cd infra/envs/dev\nterraform init\nterraform apply\n</code></pre> <p>Les ressources sont cr\u00e9\u00e9es dans l'ordre suivant : 1. VPC et subnets (publics/priv\u00e9s) 2. Security Groups 3. RDS PostgreSQL 4. ECS Cluster 5. ALB 6. ECS Services (Spring Boot, Prometheus, Grafana)</p> <p>Temps total : ~15 minutes</p>"},{"location":"architecture/ecs/#securite","title":"\ud83d\udd10 S\u00e9curit\u00e9","text":"<ul> <li>VPC : R\u00e9seau isol\u00e9 avec subnets publics (ALB) et priv\u00e9s (ECS, RDS)</li> <li>Security Groups : R\u00e8gles strictes entre composants</li> <li>RDS : Pas d'acc\u00e8s public, uniquement depuis ECS</li> <li>Secrets : Mot de passe BDD stock\u00e9 dans AWS Secrets Manager</li> <li>HTTPS : Certificat ACM sur l'ALB</li> </ul>"},{"location":"architecture/ecs/#avantages","title":"\u26a1 Avantages","text":"<ul> <li>Latence constante : Pas de cold start</li> <li>Connexions persistantes : Pool de connexions vers PostgreSQL</li> <li>Debugging facile : Logs structur\u00e9s dans CloudWatch</li> <li>\u00c9cosyst\u00e8me Java : Librairies Spring Boot \u00e9prouv\u00e9es</li> </ul>"},{"location":"architecture/ecs/#inconvenients","title":"\u26a0\ufe0f Inconv\u00e9nients","text":"<ul> <li>Co\u00fbt fixe : ~$90/mois m\u00eame sans trafic</li> <li>Scaling manuel : N\u00e9cessite configuration auto-scaling</li> <li>Gestion infrastructure : Plus complexe que Serverless</li> </ul>"},{"location":"architecture/overview/","title":"Vue d'ensemble Architecture","text":""},{"location":"architecture/overview/#principe-du-projet","title":"\ud83c\udfaf Principe du Projet","text":"<p>L'infrastructure IoT Playground permet de d\u00e9ployer deux backends distincts pour la m\u00eame application frontend. L'utilisateur peut choisir dans l'interface web quel backend utiliser (ECS ou Serverless), permettant ainsi une comparaison directe des deux approches.</p> <pre><code>graph TB\n    subgraph \"Utilisateur\"\n        USER[Utilisateur]\n        FRONTEND[Frontend Angular]\n    end\n\n    subgraph \"AWS Infrastructure\"\n        subgraph \"Mode ECS\"\n            ALB[Application Load Balancer]\n            ECS[ECS Fargate&lt;br/&gt;Spring Boot]\n            RDS[(RDS&lt;br/&gt;PostgreSQL)]\n            PROM[Prometheus]\n        end\n\n        subgraph \"Mode Serverless\"\n            APIGW[API Gateway]\n            LAMBDA_RUN[Lambda Run API]\n            LAMBDA_SENSOR[Lambda Sensor API]\n            DYNAMO[(DynamoDB&lt;br/&gt;Runs + SensorData)]\n            CW[CloudWatch Logs]\n        end\n\n        subgraph \"Monitoring\"\n            GRAFANA[Grafana ECS]\n        end\n\n        subgraph \"DNS &amp; Security\"\n            R53[Route53]\n            ACM[ACM Certificates]\n        end\n    end\n\n    USER --&gt; FRONTEND\n    FRONTEND --&gt;|HTTPS| R53\n\n    R53 --&gt; ALB\n    R53 --&gt; APIGW\n    R53 --&gt; GRAFANA\n\n    ACM -.certifie.-&gt; ALB\n    ACM -.certifie.-&gt; APIGW\n    ACM -.certifie.-&gt; GRAFANA\n\n    ALB --&gt; ECS\n    ECS --&gt; RDS\n    ECS --&gt; PROM\n    PROM --&gt; GRAFANA\n\n    APIGW --&gt; LAMBDA_RUN\n    APIGW --&gt; LAMBDA_SENSOR\n    LAMBDA_RUN --&gt; DYNAMO\n    LAMBDA_SENSOR --&gt; DYNAMO\n    LAMBDA_RUN -.log.-&gt; CW\n    LAMBDA_SENSOR -.log.-&gt; CW\n    CW --&gt; GRAFANA\n\n    style ECS fill:#fff3e0\n    style LAMBDA_RUN fill:#e8f5e9\n    style LAMBDA_SENSOR fill:#e8f5e9\n    style GRAFANA fill:#e3f2fd</code></pre>"},{"location":"architecture/overview/#backend-ecs-architecture-traditionnelle","title":"Backend ECS (Architecture Traditionnelle)","text":"<p>L'application Spring Boot tourne sur ECS Fargate avec une base de donn\u00e9es PostgreSQL h\u00e9berg\u00e9e sur RDS. Les m\u00e9triques sont expos\u00e9es via un endpoint Prometheus et visualis\u00e9es dans Grafana. Cette architecture est toujours active (always-on) ce qui garantit une latence constante mais implique des co\u00fbts fixes.</p> <p>Composants : VPC priv\u00e9, ECS Cluster, RDS PostgreSQL, ALB, Prometheus, Grafana</p>"},{"location":"architecture/overview/#backend-serverless-architecture-moderne","title":"Backend Serverless (Architecture Moderne)","text":"<p>Les APIs sont impl\u00e9ment\u00e9es en Lambda Python avec stockage dans DynamoDB. Les logs et m\u00e9triques sont envoy\u00e9s vers CloudWatch et visualis\u00e9s dans Grafana. Cette architecture est on-demand : les Lambdas ne s'ex\u00e9cutent que lors des requ\u00eates, ce qui r\u00e9duit drastiquement les co\u00fbts pour les charges l\u00e9g\u00e8res.</p> <p>Composants : Lambda Functions, DynamoDB, API Gateway, CloudWatch Logs, Grafana (optionnel)</p>"},{"location":"architecture/overview/#infrastructure-partagee","title":"\ud83c\udfd7\ufe0f Infrastructure Partag\u00e9e","text":"<p>Les deux architectures partagent certains composants communs :</p>"},{"location":"architecture/overview/#dns-et-certificats","title":"DNS et Certificats","text":"<ul> <li>Route53 g\u00e8re le domaine <code>sentori-studio.com</code></li> <li>ACM (AWS Certificate Manager) fournit les certificats HTTPS pour chaque sous-domaine</li> <li>Chaque architecture a son propre domaine personnalis\u00e9 pour isoler les environnements</li> </ul>"},{"location":"architecture/overview/#etat-terraform","title":"\u00c9tat Terraform","text":"<ul> <li>S3 Bucket stocke l'\u00e9tat Terraform de mani\u00e8re centralis\u00e9e</li> <li>DynamoDB Lock Table \u00e9vite les modifications concurrentes</li> <li>Chaque environnement (<code>dev</code>, <code>serverless-dev</code>) a sa propre cl\u00e9 d'\u00e9tat</li> </ul>"},{"location":"architecture/overview/#flux-de-donnees","title":"\ud83d\udcca Flux de Donn\u00e9es","text":""},{"location":"architecture/overview/#mode-ecs-flux-typique","title":"Mode ECS - Flux Typique","text":"<ol> <li>D\u00e9marrage simulation : Le frontend envoie <code>POST /api/runs/start</code> \u00e0 l'ALB qui route vers le conteneur Spring Boot</li> <li>Stockage : Spring Boot ins\u00e8re le run dans PostgreSQL et g\u00e9n\u00e8re un UUID</li> <li>Ingestion continue : Le frontend envoie les donn\u00e9es capteur via <code>POST /api/sensors/data</code> toutes les N secondes</li> <li>Monitoring : Prometheus scrape les m\u00e9triques expos\u00e9es par Spring Boot (<code>/actuator/prometheus</code>)</li> <li>Visualisation : Grafana query Prometheus et affiche les graphiques en temps r\u00e9el</li> </ol>"},{"location":"architecture/overview/#mode-serverless-flux-typique","title":"Mode Serverless - Flux Typique","text":"<ol> <li>D\u00e9marrage simulation : Le frontend envoie <code>POST /api/runs/start</code> \u00e0 API Gateway qui invoque Lambda Run API</li> <li>Stockage : La Lambda \u00e9crit dans DynamoDB (table Runs) et log les m\u00e9triques dans CloudWatch</li> <li>Ingestion continue : Chaque <code>POST /api/sensors/data</code> invoque Lambda Sensor API qui \u00e9crit dans DynamoDB (table SensorData)</li> <li>Monitoring : Les m\u00e9triques custom sont logg\u00e9es dans CloudWatch Logs</li> <li>Visualisation : Grafana query CloudWatch Logs avec le plugin Athena et affiche les graphiques</li> </ol>"},{"location":"architecture/overview/#securite","title":"\ud83d\udd10 S\u00e9curit\u00e9","text":""},{"location":"architecture/overview/#authentification","title":"Authentification","text":"<p>Actuellement, l'authentification est g\u00e9r\u00e9e via un simple header HTTP <code>X-User</code> qui identifie l'utilisateur. Ce m\u00e9canisme simple permet de s\u00e9parer les simulations par utilisateur sans n\u00e9cessiter un syst\u00e8me d'authentification complet (JWT, OAuth).</p>"},{"location":"architecture/overview/#reseau","title":"R\u00e9seau","text":"<ul> <li>VPC priv\u00e9 : Les bases de donn\u00e9es (RDS, ECS tasks) sont dans des subnets priv\u00e9s</li> <li>Security Groups : R\u00e8gles de pare-feu strictes limitant l'acc\u00e8s inter-services</li> <li>Public Subnets : Uniquement les ALB et NAT Gateways sont expos\u00e9s publiquement</li> </ul>"},{"location":"architecture/overview/#chiffrement","title":"Chiffrement","text":"<ul> <li>HTTPS : Tous les endpoints utilisent des certificats ACM</li> <li>Encryption at Rest : DynamoDB et RDS chiffrent les donn\u00e9es au repos</li> <li>Encryption in Transit : TLS 1.2+ obligatoire sur tous les endpoints</li> </ul>"},{"location":"architecture/overview/#environnements","title":"\ud83c\udf9b\ufe0f Environnements","text":"<p>Le projet d\u00e9finit plusieurs environnements Terraform isol\u00e9s :</p> <ul> <li><code>dev/</code> : Architecture ECS compl\u00e8te (Spring Boot + PostgreSQL)</li> <li><code>serverless-dev/</code> : Architecture Serverless (Lambda + DynamoDB)</li> <li><code>cdn-dev/</code> : H\u00e9bergement frontend via CloudFront (futur)</li> </ul> <p>Chaque environnement a son propre \u00e9tat Terraform, permettant de d\u00e9ployer/d\u00e9truire les ressources ind\u00e9pendamment.</p>"},{"location":"architecture/serverless/","title":"Architecture Serverless","text":""},{"location":"architecture/serverless/#vue-densemble","title":"\ud83c\udfaf Vue d'ensemble","text":"<p>L'architecture Serverless remplace compl\u00e8tement le backend Spring Boot par des fonctions Lambda Python et la base PostgreSQL par DynamoDB. Cette approche \"sans serveur\" permet de ne payer que pour les requ\u00eates effectu\u00e9es, r\u00e9duisant drastiquement les co\u00fbts pour les applications \u00e0 faible trafic.</p> <pre><code>graph LR\n    FRONTEND[Frontend] --&gt;|HTTPS| APIGW[API Gateway]\n\n    APIGW --&gt;|invoke| LAMBDA_RUN[Lambda Run API&lt;br/&gt;Python 3.11]\n    APIGW --&gt;|invoke| LAMBDA_SENSOR[Lambda Sensor API&lt;br/&gt;Python 3.11]\n\n    LAMBDA_RUN --&gt; DYNAMO_RUNS[(DynamoDB&lt;br/&gt;Runs)]\n    LAMBDA_SENSOR --&gt; DYNAMO_DATA[(DynamoDB&lt;br/&gt;SensorData)]\n\n    LAMBDA_RUN -.log.-&gt; CW[CloudWatch Logs]\n    LAMBDA_SENSOR -.log.-&gt; CW\n\n    CW --&gt; GRAFANA[Grafana]\n\n    style LAMBDA_RUN fill:#e8f5e9\n    style LAMBDA_SENSOR fill:#e8f5e9\n    style APIGW fill:#e1f5ff</code></pre>"},{"location":"architecture/serverless/#composants-principaux","title":"Composants Principaux","text":"<p>API Gateway : Point d'entr\u00e9e HTTPS (<code>api-lambda-iot.sentori-studio.com</code>) qui route les requ\u00eates vers les Lambdas appropri\u00e9es</p> <p>Lambda Functions : Deux fonctions Python 3.11 isol\u00e9es : - <code>lambda_run_api</code> : Gestion des simulations (d\u00e9marrer, finir, lister) - <code>lambda_sensor_api</code> : Ingestion et r\u00e9cup\u00e9ration des donn\u00e9es capteurs</p> <p>DynamoDB : Deux tables NoSQL en mode on-demand : - <code>Runs</code> : Stocke les m\u00e9tadonn\u00e9es des simulations - <code>SensorData</code> : Stocke les mesures des capteurs</p> <p>CloudWatch Logs : Collecte les logs et m\u00e9triques custom des Lambdas</p> <p>Grafana (Optionnel) : Conteneur ECS qui query CloudWatch pour afficher les dashboards</p>"},{"location":"architecture/serverless/#services-aws-utilises","title":"Services AWS Utilis\u00e9s","text":"Service Usage Justification Lambda Ex\u00e9cution code Python Pay-per-use, scaling automatique API Gateway Endpoint REST Gestion HTTPS, throttling, monitoring DynamoDB Stockage NoSQL Performance, pay-per-request, pas de gestion serveur CloudWatch Logs et m\u00e9triques Natif AWS, gratuit jusqu'\u00e0 5 GB Route53 DNS custom domain Gestion domaine sentori-studio.com ACM Certificat HTTPS Gratuit, renouvellement auto VPC (Grafana) R\u00e9seau isol\u00e9 S\u00e9curit\u00e9 pour Grafana ECS Fargate (Grafana) Grafana container Grafana non disponible en Lambda"},{"location":"architecture/serverless/#ressources-aws","title":"\ud83d\udccb Ressources AWS","text":""},{"location":"architecture/serverless/#lambda-functions","title":"Lambda Functions","text":"Fonction Runtime M\u00e9moire Timeout Trigger run-api Python 3.11 512 MB 30s API Gateway sensor-api Python 3.11 512 MB 30s API Gateway"},{"location":"architecture/serverless/#dynamodb-tables","title":"DynamoDB Tables","text":"<p>Runs Table <pre><code>Partition Key: id (String, UUID)\nAttributes:\n  - username (String)\n  - status (String: RUNNING, COMPLETED, FAILED, INTERRUPTED)\n  - startedAt (String, ISO 8601)\n  - finishedAt (String, ISO 8601, optional)\n  - duration (Number, seconds)\n  - interval (Number, seconds)\n  - params (Map)\n  - grafanaUrl (String)\n</code></pre></p> <p>SensorData Table <pre><code>Partition Key: id (String, UUID)\nSort Key: timestamp (String, ISO 8601)\nAttributes:\n  - runId (String, UUID)\n  - username (String)\n  - sensorId (String)\n  - temperature (Number)\n  - humidity (Number, optional)\n  - pressure (Number, optional)\n</code></pre></p>"},{"location":"architecture/serverless/#flux-api","title":"\ud83d\udd04 Flux API","text":""},{"location":"architecture/serverless/#demarrer-une-simulation","title":"D\u00e9marrer une Simulation","text":"<ol> <li>Frontend envoie <code>POST /api/runs/start</code> avec <code>{duration, interval}</code></li> <li>API Gateway invoque <code>lambda_run_api</code></li> <li>Lambda v\u00e9rifie la limite (max 5 simulations concurrentes globales)</li> <li>Si OK : g\u00e9n\u00e8re un UUID, \u00e9crit dans DynamoDB <code>Runs</code> avec status <code>RUNNING</code></li> <li>Retourne <code>{id, grafanaUrl, ...}</code> au frontend</li> </ol>"},{"location":"architecture/serverless/#ingerer-des-donnees-capteur","title":"Ing\u00e9rer des Donn\u00e9es Capteur","text":"<ol> <li>Frontend envoie <code>POST /api/sensors/data</code> avec <code>{runId, sensorId, temperature}</code></li> <li>API Gateway invoque <code>lambda_sensor_api</code></li> <li>Lambda valide les donn\u00e9es et \u00e9crit dans DynamoDB <code>SensorData</code></li> <li>Logs les m\u00e9triques custom dans CloudWatch</li> <li>Retourne <code>201 Created</code></li> </ol> <p>Le frontend r\u00e9p\u00e8te cette op\u00e9ration toutes les N secondes (selon l'interval configur\u00e9) jusqu'\u00e0 la fin de la simulation.</p>"},{"location":"architecture/serverless/#endpoints-api","title":"\ud83c\udf9b\ufe0f Endpoints API","text":""},{"location":"architecture/serverless/#run-controller","title":"Run Controller","text":"M\u00e9thode Endpoint Description GET <code>/api/runs/can-start</code> V\u00e9rifier limite (5 max global) GET <code>/api/runs/running</code> Lister runs actifs (tous users) POST <code>/api/runs/start</code> D\u00e9marrer simulation POST <code>/api/runs/{id}/finish</code> Terminer simulation POST <code>/api/runs/interrupt-all</code> Interrompre toutes simulations GET <code>/api/runs/{id}</code> D\u00e9tails d'un run GET <code>/api/runs</code> Liste pagin\u00e9e GET <code>/api/runs/all</code> Tous les runs"},{"location":"architecture/serverless/#sensor-controller","title":"Sensor Controller","text":"M\u00e9thode Endpoint Description POST <code>/api/sensors/data</code> Ing\u00e9rer donn\u00e9es capteur GET <code>/api/sensors/data</code> R\u00e9cup\u00e9rer donn\u00e9es"},{"location":"architecture/serverless/#monitoring-cloudwatch","title":"\ud83d\udcca Monitoring CloudWatch","text":"<p>CloudWatch collecte automatiquement plusieurs types de m\u00e9triques :</p>"},{"location":"architecture/serverless/#metriques-lambda-standard","title":"M\u00e9triques Lambda Standard","text":"<ul> <li>Invocations : Nombre d'appels aux fonctions</li> <li>Duration : Temps d'ex\u00e9cution moyen</li> <li>Errors : Taux d'erreur</li> <li>Throttles : Invocations rejet\u00e9es par limite de concurrence</li> </ul>"},{"location":"architecture/serverless/#metriques-custom","title":"M\u00e9triques Custom","text":"<p>Les Lambdas loggent des m\u00e9triques m\u00e9tier sp\u00e9cifiques : - <code>run_started</code> / <code>run_completed</code> : Suivi des simulations - <code>sensor_data_ingested</code> : Volume de donn\u00e9es capteur - <code>temperature_avg</code> : Temp\u00e9rature moyenne par run</p>"},{"location":"architecture/serverless/#metriques-dynamodb","title":"M\u00e9triques DynamoDB","text":"<ul> <li>ConsumedReadCapacity / ConsumedWriteCapacity : Utilisation des tables</li> <li>SuccessfulRequestLatency : Latence des requ\u00eates</li> </ul> <p>Grafana query ces m\u00e9triques via le plugin CloudWatch pour afficher des dashboards temps r\u00e9el.</p>"},{"location":"architecture/serverless/#couts","title":"\ud83d\udcb0 Co\u00fbts","text":"<p>Configuration actuelle (serverless-dev)</p> Ressource Co\u00fbt Idle Co\u00fbt Actif (estimation) Lambda (2 fonctions) $0 $0.0000002 / invocation DynamoDB (2 tables, on-demand) $0 $0.25 / million writes API Gateway $0 $3.50 / million requests CloudWatch Logs ~$0.50/mois Variable Grafana ECS ~$40/mois ~$40/mois VPC (NAT, IGW) ~$40/mois ~$40/mois TOTAL ~$80/mois ~$80/mois + usage <p>\u00c9conomie</p> <p>Pour r\u00e9duire les co\u00fbts, d\u00e9truire Grafana quand non utilis\u00e9 : <pre><code>Component: grafana\nAction: destroy\n</code></pre> \u2192 Co\u00fbt idle : ~$1/mois (CloudWatch Logs uniquement)</p>"},{"location":"architecture/serverless/#securite","title":"\ud83d\udd10 S\u00e9curit\u00e9","text":""},{"location":"architecture/serverless/#api-gateway","title":"API Gateway","text":"<ul> <li>HTTPS obligatoire : Certificat ACM wildcard pour <code>*.sentori-studio.com</code></li> <li>Custom Domain : Domaine personnalis\u00e9 avec Route53</li> <li>CORS configur\u00e9 : Headers autoris\u00e9s pour le frontend Angular</li> </ul>"},{"location":"architecture/serverless/#lambda","title":"Lambda","text":"<ul> <li>IAM Execution Role : Permissions minimales (lecture/\u00e9criture DynamoDB, logs CloudWatch)</li> <li>Environment Variables : Configuration inject\u00e9e au runtime (tables DynamoDB, r\u00e9gion)</li> <li>Pas de VPC : Les Lambdas sont publiques pour r\u00e9duire les co\u00fbts (pas de NAT Gateway)</li> </ul>"},{"location":"architecture/serverless/#dynamodb","title":"DynamoDB","text":"<ul> <li>Encryption at Rest : Chiffrement automatique avec cl\u00e9s AWS</li> <li>IAM Permissions : Acc\u00e8s restreint aux Lambdas uniquement</li> </ul>"},{"location":"architecture/serverless/#deploiement","title":"\ud83d\ude80 D\u00e9ploiement","text":"<p>Le d\u00e9ploiement est g\u00e9r\u00e9 via GitHub Actions avec un workflow unifi\u00e9 (<code>deploy-serverless-unified.yml</code>) qui permet de d\u00e9ployer :</p> <ul> <li>Lambdas uniquement : DynamoDB + Lambda Functions + API Gateway (~5 min)</li> <li>Grafana uniquement : VPC + ECS + ALB (~10 min)</li> <li>Full : Tout l'environnement serverless (~15 min)</li> </ul> <p>Les ressources sont cr\u00e9\u00e9es avec Terraform en utilisant des targets pour d\u00e9ployer/d\u00e9truire de mani\u00e8re granulaire et ind\u00e9pendante.</p>"},{"location":"deployment/ecs/","title":"D\u00e9ploiement Infrastructure ECS","text":""},{"location":"deployment/ecs/#infrastructure-manager","title":"\ud83c\udfaf Infrastructure Manager","text":"<p>L'infrastructure ECS utilise un syst\u00e8me Infrastructure Manager qui permet de cr\u00e9er et d\u00e9truire l'infrastructure compl\u00e8te \u00e0 la demande via une API.</p>"},{"location":"deployment/ecs/#principe-de-fonctionnement","title":"Principe de Fonctionnement","text":"<p>L'infrastructure ECS n'est pas toujours active pour \u00e9conomiser les co\u00fbts. Elle peut \u00eatre d\u00e9marr\u00e9e uniquement quand n\u00e9cessaire via le frontend.</p> <pre><code>graph TB\n    subgraph \"Frontend Angular\"\n        USER[Utilisateur]\n        BUTTON[Bouton Start/Stop Infrastructure]\n    end\n\n    subgraph \"Infrastructure Manager\"\n        API[Lambda Infra Manager]\n        SF[Step Functions]\n    end\n\n    subgraph \"Infrastructure ECS\"\n        STATUS{\u00c9tat Infra}\n        TERRAFORM[Terraform Apply/Destroy]\n        INFRA[ECS + RDS + ALB]\n    end\n\n    USER --&gt;|Clique| BUTTON\n    BUTTON --&gt;|API Call| API\n\n    API --&gt; STATUS\n\n    STATUS --&gt;|Stopped| TERRAFORM\n    STATUS --&gt;|Running| TERRAFORM\n\n    TERRAFORM --&gt;|Create| INFRA\n    TERRAFORM --&gt;|Destroy| INFRA\n\n    INFRA -.Status.-&gt; API\n    API -.Response.-&gt; BUTTON\n\n    style API fill:#e8f5e9\n    style INFRA fill:#fff3e0</code></pre>"},{"location":"deployment/ecs/#cycle-de-vie","title":"\ud83d\udd04 Cycle de Vie","text":""},{"location":"deployment/ecs/#demarrage-de-linfrastructure","title":"D\u00e9marrage de l'Infrastructure","text":"<ol> <li>Frontend : L'utilisateur clique sur \"D\u00e9marrer Infrastructure ECS\"</li> <li>API Call : Le frontend appelle <code>POST /infra/start</code></li> <li>Lambda Manager : D\u00e9clenche un Step Functions workflow</li> <li>Terraform Apply : Cr\u00e9e toutes les ressources (VPC, ECS, RDS, ALB)</li> <li>Attente : Le processus prend ~15 minutes</li> <li>Ready : L'infrastructure est pr\u00eate, l'API ECS est accessible</li> </ol>"},{"location":"deployment/ecs/#arret-de-linfrastructure","title":"Arr\u00eat de l'Infrastructure","text":"<ol> <li>Frontend : L'utilisateur clique sur \"Arr\u00eater Infrastructure ECS\"</li> <li>API Call : Le frontend appelle <code>POST /infra/stop</code></li> <li>Lambda Manager : D\u00e9clenche un Step Functions workflow</li> <li>Terraform Destroy : Supprime toutes les ressources</li> <li>Attente : Le processus prend ~10 minutes</li> <li>Stopped : L'infrastructure est d\u00e9truite, plus de co\u00fbts</li> </ol>"},{"location":"deployment/ecs/#etats-de-linfrastructure","title":"\ud83d\udcca \u00c9tats de l'Infrastructure","text":"\u00c9tat Description Actions disponibles STOPPED Infrastructure d\u00e9truite Start STARTING Cr\u00e9ation en cours (~15 min) - RUNNING Infrastructure active Stop, Use API STOPPING Destruction en cours (~10 min) - ERROR Erreur lors de l'op\u00e9ration Retry"},{"location":"deployment/ecs/#api-infrastructure-manager","title":"\ud83c\udf9b\ufe0f API Infrastructure Manager","text":""},{"location":"deployment/ecs/#get-infrastatus","title":"GET <code>/infra/status</code>","text":"<p>R\u00e9cup\u00e8re l'\u00e9tat actuel de l'infrastructure ECS.</p> <p>Response 200 <pre><code>{\n  \"status\": \"RUNNING\",\n  \"endpoint\": \"https://api-ecs-iot.sentori-studio.com\",\n  \"lastUpdate\": \"2025-01-15T10:30:00Z\"\n}\n</code></pre></p>"},{"location":"deployment/ecs/#post-infrastart","title":"POST <code>/infra/start</code>","text":"<p>D\u00e9marre l'infrastructure ECS.</p> <p>Response 202 <pre><code>{\n  \"message\": \"Infrastructure starting\",\n  \"estimatedTime\": \"15 minutes\"\n}\n</code></pre></p>"},{"location":"deployment/ecs/#post-infrastop","title":"POST <code>/infra/stop</code>","text":"<p>Arr\u00eate l'infrastructure ECS.</p> <p>Response 202 <pre><code>{\n  \"message\": \"Infrastructure stopping\",\n  \"estimatedTime\": \"10 minutes\"\n}\n</code></pre></p>"},{"location":"deployment/ecs/#optimisation-des-couts","title":"\ud83d\udcb0 Optimisation des Co\u00fbts","text":"<p>Ce syst\u00e8me permet d'\u00e9conomiser significativement sur les co\u00fbts AWS :</p> <ul> <li>Sans Infrastructure Manager : Infrastructure toujours active = ~$90/mois</li> <li>Avec Infrastructure Manager : Infrastructure active 8h/jour = ~$30/mois</li> <li>Usage occasionnel : Infrastructure active 2h/semaine = ~$5/mois</li> </ul> <p>Le co\u00fbt de l'Infrastructure Manager lui-m\u00eame (Lambda + Step Functions) est n\u00e9gligeable (~$1/mois).</p>"},{"location":"deployment/ecs/#deploiement-de-linfrastructure-manager","title":"\ud83d\ude80 D\u00e9ploiement de l'Infrastructure Manager","text":"<pre><code>cd infra/envs/inframanager-dev\nterraform init\nterraform apply\n</code></pre> <p>Une fois d\u00e9ploy\u00e9, l'Infrastructure Manager est accessible depuis le frontend et permet de contr\u00f4ler l'infrastructure ECS \u00e0 la demande.</p>"},{"location":"deployment/ecs/#liens","title":"\ud83d\udd17 Liens","text":"<ul> <li>Architecture ECS</li> <li>Guide Serverless</li> </ul>"},{"location":"deployment/github-actions/","title":"GitHub Actions Workflows","text":"<p>Le projet utilise GitHub Actions pour piloter les d\u00e9ploiements d\u2019infrastructure et la documentation, sans avoir \u00e0 lancer Terraform manuellement.</p>"},{"location":"deployment/github-actions/#resume-des-workflows","title":"\ud83d\udccb R\u00e9sum\u00e9 des workflows","text":"<p>Deploy Serverless (Unified) - D\u00e9ploie l\u2019architecture serverless (Lambdas + DynamoDB + API Gateway, et \u00e9ventuellement Grafana sur ECS). - Permet de choisir quel composant d\u00e9ployer (<code>lambdas</code>, <code>grafana</code> ou <code>full</code>) et si l\u2019on veut juste un plan ou un apply.</p> <p>Destroy Serverless - D\u00e9truit l\u2019architecture serverless de fa\u00e7on contr\u00f4l\u00e9e. - M\u00eame logique de s\u00e9lection (<code>lambdas</code>, <code>grafana</code>, <code>full</code>) avec une confirmation explicite avant destruction.</p> <p>Deploy MkDocs Documentation - Construit et publie automatiquement la documentation sur GitHub Pages. - Se d\u00e9clenche sur les changements de la doc ou \u00e0 la demande.</p> <p>Ces trois workflows montrent que toute l\u2019infrastructure (et la doc) est g\u00e9r\u00e9e de bout en bout via GitHub, ce qui facilite les d\u00e9mos et les d\u00e9ploiements reproductibles.</p>"},{"location":"deployment/github-actions/#vue-densemble","title":"\ud83d\udd04 Vue d\u2019ensemble","text":"<pre><code>graph TD\n    A[D\u00e9veloppeur] --&gt;|Push / Run workflow| B[GitHub Actions]\n\n    B --&gt; C{Workflow}\n\n    C --&gt;|Serverless&lt;br/&gt;Deploy| D[Deploy Serverless]\n    C --&gt;|Serverless&lt;br/&gt;Destroy| E[Destroy Serverless]\n    C --&gt;|Documentation| F[Deploy Docs]\n\n    D --&gt; G[Infra Serverless \u00e0 jour]\n    E --&gt; H[Infra Serverless d\u00e9truite]\n    F --&gt; I[Site MkDocs publi\u00e9]\n\n    style D fill:#e8f5e9\n    style E fill:#ffe0b2\n    style F fill:#e3f2fd</code></pre>"},{"location":"deployment/github-actions/#securite-vue-haute-niveau","title":"\ud83d\udd10 S\u00e9curit\u00e9 (vue haute niveau)","text":"<p>Les workflows utilisent un r\u00f4le AWS technique via des secrets GitHub (Access Key / Secret Key) pour ex\u00e9cuter Terraform c\u00f4t\u00e9 CI. L\u2019historique complet des ex\u00e9cutions est visible dans l\u2019onglet Actions du repository.</p>"},{"location":"deployment/prerequisites/","title":"Pr\u00e9requis","text":""},{"location":"deployment/prerequisites/#outils-necessaires","title":"\ud83d\udd27 Outils N\u00e9cessaires","text":""},{"location":"deployment/prerequisites/#aws-cli","title":"AWS CLI","text":"<pre><code># Installation\n# Windows (PowerShell)\nmsiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi\n\n# macOS\nbrew install awscli\n\n# Linux\ncurl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"\nunzip awscliv2.zip\nsudo ./aws/install\n\n# Configuration\naws configure\n# AWS Access Key ID: [Votre Access Key]\n# AWS Secret Access Key: [Votre Secret Key]\n# Default region: eu-west-3\n# Default output format: json\n</code></pre>"},{"location":"deployment/prerequisites/#terraform","title":"Terraform","text":"<pre><code># Version requise: &gt;= 1.6.0\n\n# Windows (Chocolatey)\nchoco install terraform\n\n# macOS\nbrew install terraform\n\n# Linux\nwget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip\nunzip terraform_1.6.0_linux_amd64.zip\nsudo mv terraform /usr/local/bin/\n</code></pre>"},{"location":"deployment/prerequisites/#verification","title":"V\u00e9rification","text":"<pre><code>aws --version\n# aws-cli/2.x.x\n\nterraform --version\n# Terraform v1.6.0 ou sup\u00e9rieur\n</code></pre>"},{"location":"deployment/prerequisites/#permissions-iam-requises","title":"\ud83d\udd10 Permissions IAM Requises","text":"<p>L'utilisateur AWS doit avoir les permissions suivantes :</p> <ul> <li>Lambda : Cr\u00e9ation et gestion des fonctions</li> <li>DynamoDB : Cr\u00e9ation et gestion des tables</li> <li>API Gateway : Cr\u00e9ation et configuration</li> <li>ECS : Gestion des clusters et services</li> <li>RDS : Cr\u00e9ation et gestion des bases de donn\u00e9es</li> <li>VPC : Cr\u00e9ation et gestion du r\u00e9seau</li> <li>IAM : Cr\u00e9ation de r\u00f4les et policies</li> <li>CloudWatch : Logs et m\u00e9triques</li> <li>Route53 : Gestion DNS</li> <li>ACM : Certificats SSL/TLS</li> <li>S3 : Stockage \u00e9tat Terraform</li> <li>ECR : Registry Docker</li> </ul>"},{"location":"deployment/prerequisites/#domaine-dns","title":"\ud83c\udf10 Domaine DNS","text":"<p>Un domaine configur\u00e9 dans Route53 est requis : - Domaine : <code>sentori-studio.com</code> - Hosted Zone configur\u00e9e dans Route53</p>"},{"location":"deployment/prerequisites/#github-secrets","title":"\ud83d\udd11 GitHub Secrets","text":"<p>Pour les d\u00e9ploiements via GitHub Actions, configurer les secrets suivants dans le repository :</p> <pre><code>AWS_ACCESS_KEY_ID\nAWS_SECRET_ACCESS_KEY\n</code></pre> <p>Configuration : Settings \u2192 Secrets and variables \u2192 Actions \u2192 New repository secret</p>"},{"location":"deployment/prerequisites/#checklist-finale","title":"\u2705 Checklist Finale","text":"<ul> <li>[ ] AWS CLI install\u00e9 et configur\u00e9</li> <li>[ ] Terraform &gt;= 1.6.0 install\u00e9</li> <li>[ ] Credentials AWS valides</li> <li>[ ] Permissions IAM suffisantes</li> <li>[ ] Domaine Route53 configur\u00e9</li> <li>[ ] GitHub Secrets configur\u00e9s (pour CI/CD)</li> </ul>"},{"location":"deployment/serverless/","title":"Infrastructure Serverless","text":"<p>Cette page d\u00e9crit l\u2019infrastructure Serverless mise en place pour remplacer le backend Spring Boot par des Lambdas Python, tout en gardant la m\u00eame exp\u00e9rience fonctionnelle c\u00f4t\u00e9 frontend.</p>"},{"location":"deployment/serverless/#objectif","title":"\ud83c\udfaf Objectif","text":"<ul> <li>Offrir un backend full serverless pour l\u2019application IoT Playground</li> <li>Conserver les m\u00eames endpoints REST que l\u2019API Spring Boot</li> <li>S\u2019appuyer sur des services manag\u00e9s uniquement (Lambda, DynamoDB, API Gateway, CloudWatch)</li> </ul>"},{"location":"deployment/serverless/#composants-principaux","title":"\ud83e\uddf1 Composants principaux","text":"<ul> <li>API Gateway : point d\u2019entr\u00e9e HTTPS pour toutes les requ\u00eates <code>/api/...</code></li> <li>Lambda Run API : g\u00e8re les runs (can-start, start, finish, interrupt-all)</li> <li>Lambda Sensor API : g\u00e8re l\u2019ingestion des donn\u00e9es capteurs</li> <li>DynamoDB : stocke les runs et les mesures (NoSQL, on-demand)</li> <li>CloudWatch Logs &amp; Metrics : centralise les logs et expose les m\u00e9triques</li> <li>Grafana (sur ECS) : dashboard d\u00e9di\u00e9 aux m\u00e9triques CloudWatch serverless</li> </ul>"},{"location":"deployment/serverless/#schema-darchitecture","title":"\ud83d\uddfa\ufe0f Sch\u00e9ma d\u2019architecture","text":"<pre><code>graph LR\n    FRONT[Frontend Angular] --&gt;|HTTPS /api/...| APIGW[API Gateway]\n\n    APIGW --&gt;|/api/runs/*| L_RUN[Lambda Run API]\n    APIGW --&gt;|/api/sensors/*| L_SENSOR[Lambda Sensor API]\n\n    L_RUN --&gt; DDB_RUNS[(DynamoDB&lt;br/&gt;Runs)]\n    L_SENSOR --&gt; DDB_DATA[(DynamoDB&lt;br/&gt;SensorData)]\n\n    L_RUN -.logs/metrics.-&gt; CW[CloudWatch]\n    L_SENSOR -.logs/metrics.-&gt; CW\n\n    CW --&gt; GRAF[Grafana ECS]\n\n    style L_RUN fill:#e8f5e9\n    style L_SENSOR fill:#e8f5e9\n    style APIGW fill:#e1f5ff\n    style GRAF fill:#e3f2fd</code></pre>"},{"location":"deployment/serverless/#cycle-de-vie-dune-simulation","title":"\ud83d\udd04 Cycle de vie d\u2019une simulation","text":"<ol> <li>D\u00e9marrage : le frontend appelle <code>/api/runs/start</code> (via API Gateway) \u2192 Lambda Run API cr\u00e9e un run <code>RUNNING</code> dans DynamoDB.</li> <li>Ingestion : \u00e0 chaque intervalle, le frontend envoie <code>/api/sensors/data</code> \u2192 Lambda Sensor API enregistre les mesures dans <code>SensorData</code>.</li> <li>Monitoring : les Lambdas \u00e9mettent des logs et m\u00e9triques dans CloudWatch \u2192 Grafana affiche l\u2019\u00e9volution des capteurs (filtr\u00e9 par Run, User, Sensor).</li> <li>Fin / interruption : <code>/api/runs/{id}/finish</code> ou <code>/api/runs/interrupt-all</code> mettent \u00e0 jour l\u2019\u00e9tat du run dans DynamoDB.</li> </ol>"},{"location":"deployment/serverless/#infrastructure-as-code","title":"\ud83e\udde9 Infrastructure as Code","text":"<p>L\u2019infrastructure Serverless est d\u00e9crite dans <code>infra/envs/serverless-dev/</code> :</p> <ul> <li>Modules utilis\u00e9s :</li> <li><code>serverless/dynamodb_tables</code> pour les tables Runs et SensorData</li> <li><code>serverless/lambda_run_api</code> et <code>serverless/lambda_sensor_api</code> pour les fonctions Python</li> <li><code>serverless/api_gateway_lambda_iot</code> pour l\u2019API Gateway + mappings</li> <li> <p><code>acm_certificate</code> et Route53 pour le domaine <code>api-lambda-iot.sentori-studio.com</code></p> </li> <li> <p>Backend Terraform :</p> </li> <li>S3 pour l\u2019\u00e9tat (<code>iot-playground-tfstate-serverless</code>)</li> <li>Table DynamoDB pour le lock des d\u00e9ploiements</li> </ul>"},{"location":"deployment/serverless/#deploiement-vue-conceptuelle","title":"\ud83d\ude80 D\u00e9ploiement (vue conceptuelle)","text":"<p>Les d\u00e9ploiements sont d\u00e9clench\u00e9s via GitHub Actions :</p> <ul> <li>Workflow Deploy Serverless (Unified) :</li> <li><code>component = lambdas</code> \u2192 Lambda + DynamoDB + API Gateway</li> <li><code>component = full</code> \u2192 + Grafana serverless</li> <li>Workflow Destroy Serverless :</li> <li>Permet de supprimer proprement les ressources quand elles ne sont plus n\u00e9cessaires.</li> </ul> <p>L\u2019id\u00e9e est de pouvoir activer/d\u00e9sactiver rapidement l\u2019environnement serverless pour des d\u00e9mos ou des comparaisons avec l\u2019architecture ECS, sans d\u00e9pendre de commandes manuelles.</p>"},{"location":"guide/grafana/","title":"Monitoring avec Grafana","text":"<p>Cette page explique comment Grafana est utilis\u00e9 pour observer les simulations, sans entrer dans les d\u00e9tails de configuration.</p>"},{"location":"guide/grafana/#role-de-grafana","title":"\ud83c\udfaf R\u00f4le de Grafana","text":"<p>Grafana sert d'interface unique pour : - Visualiser l'\u00e9volution des temp\u00e9ratures dans le temps - Filtrer par Run, User et Sensor - Comparer des simulations c\u00f4t\u00e9 ECS et c\u00f4t\u00e9 Serverless</p>"},{"location":"guide/grafana/#dashboards","title":"\ud83d\udcca Dashboards","text":"<p>Deux grandes familles de dashboards :</p> <ol> <li>Dashboard ECS (Prometheus) </li> <li>Datasource : Prometheus</li> <li>Focus sur : m\u00e9triques techniques JVM, requ\u00eates HTTP, status codes, etc.</li> <li> <p>Sert surtout \u00e0 analyser le comportement de l'application Spring Boot.</p> </li> <li> <p>Dashboard Serverless (CloudWatch) </p> </li> <li>Datasource : CloudWatch Logs / Metrics</li> <li>Focus sur :<ul> <li>Nombre de runs d\u00e9marr\u00e9s / termin\u00e9s</li> <li>Volume de donn\u00e9es capteur ing\u00e9r\u00e9es</li> <li>Latence et erreurs des Lambdas</li> <li>Temp\u00e9rature moyenne par run / sensor / user</li> </ul> </li> </ol>"},{"location":"guide/grafana/#acces","title":"\ud83c\udf10 Acc\u00e8s","text":"<ul> <li>Frontend : <code>https://app-iot.sentori-studio.com</code> propose des liens directs vers les dashboards</li> <li>Grafana Serverless : expos\u00e9 via un ALB avec HTTPS, accessible sur un sous-domaine d\u00e9di\u00e9</li> </ul> <p>L'utilisateur n'a pas besoin de conna\u00eetre l'URL exacte : le frontend injecte d\u00e9j\u00e0 l'URL Grafana li\u00e9e au run dans les r\u00e9ponses de l'API.</p>"},{"location":"guide/grafana/#points-interessants-a-presenter-en-entretien","title":"\ud83d\udd0d Points int\u00e9ressants \u00e0 pr\u00e9senter en entretien","text":"<ul> <li>La diff\u00e9rence de datasource illustre bien la s\u00e9paration ECS vs Serverless :</li> <li>Prometheus c\u00f4t\u00e9 ECS</li> <li>CloudWatch c\u00f4t\u00e9 Serverless</li> <li>Les dashboards sont construits autour des m\u00eames dimensions m\u00e9tier : user, run, sensor.</li> <li>L'URL Grafana est renvoy\u00e9e par l'API <code>/api/runs/start</code>, ce qui montre l'int\u00e9gration forte entre backend et observabilit\u00e9.</li> </ul> <p>En r\u00e9sum\u00e9, Grafana est la \"vitre\" qui permet de voir ce qui se passe derri\u00e8re les deux architectures, avec un focus m\u00e9tier plut\u00f4t que purement technique.</p>"},{"location":"guide/quickstart/","title":"D\u00e9marrage Rapide","text":"<p>Cette section explique comment l\u2019utilisateur final utilise la plateforme, sans entrer dans les d\u00e9tails techniques (pas de commandes, pas de pr\u00e9requis).</p>"},{"location":"guide/quickstart/#parcours-utilisateur-mode-serverless","title":"\ud83c\udfaf Parcours Utilisateur (Mode Serverless)","text":"<ol> <li> <p>Acc\u00e8s au frontend    L\u2019utilisateur ouvre l\u2019interface sur <code>https://app-iot.sentori-studio.com/</code>.</p> </li> <li> <p>Choix du mode    Sur l\u2019\u00e9cran d\u2019accueil, il peut choisir entre :</p> </li> <li>Mode ECS : backend Spring Boot sur ECS + PostgreSQL</li> <li> <p>Mode Serverless : backend Lambda + DynamoDB</p> </li> <li> <p>Cr\u00e9ation d\u2019une simulation (Run)    En mode Serverless :</p> </li> <li>L\u2019utilisateur indique une dur\u00e9e (ex: 60 secondes)</li> <li>Un intervalle (ex: 5 secondes entre chaque mesure)</li> <li>Il lance la simulation via un bouton du type \"Start Simulation\".</li> </ol> <p>En arri\u00e8re-plan, le frontend appelle l\u2019API <code>/api/runs/start</code> qui :    - V\u00e9rifie qu\u2019on ne d\u00e9passe pas le nombre max de simulations concurrentes (5)    - Cr\u00e9e un run dans DynamoDB avec l\u2019\u00e9tat <code>RUNNING</code>    - Retourne un identifiant de run et une URL Grafana associ\u00e9e.</p> <ol> <li>Ingestion des donn\u00e9es capteurs    Le frontend (ou un simulateur c\u00f4t\u00e9 client) envoie r\u00e9guli\u00e8rement des mesures pour ce run :</li> <li>Temp\u00e9rature</li> <li>(\u00e9ventuellement) Humidit\u00e9, pression, etc.</li> </ol> <p>Ces mesures sont stock\u00e9es dans la table <code>SensorData</code> en DynamoDB et logg\u00e9es dans CloudWatch pour le monitoring.</p> <ol> <li>Visualisation dans Grafana    L\u2019interface propose un lien direct vers le dashboard Grafana correspondant :</li> <li>Vue globale de toutes les temp\u00e9ratures</li> <li>Filtres par Run, User et Sensor</li> <li> <p>Possibilit\u00e9 de comparer plusieurs runs entre eux.</p> </li> <li> <p>Fin ou interruption de la simulation    L\u2019utilisateur peut :</p> </li> <li>Laisser la simulation aller jusqu\u2019au bout (dur\u00e9e configur\u00e9e)</li> <li>La terminer explicitement (\"Finish Run\")</li> <li>Interrompre toutes les simulations en cours (\"Interrupt All\")</li> </ol> <p>C\u00f4t\u00e9 backend, l\u2019\u00e9tat du run passe \u00e0 <code>COMPLETED</code>, <code>FAILED</code> ou <code>INTERRUPTED</code>.</p>"},{"location":"guide/quickstart/#parcours-utilisateur-mode-ecs","title":"\ud83e\udded Parcours Utilisateur (Mode ECS)","text":"<p>Le parcours est volontairement identique c\u00f4t\u00e9 frontend : - M\u00eame \u00e9crans - M\u00eame endpoints REST - M\u00eame concepts (Runs, Sensors, Users)</p> <p>La diff\u00e9rence est strictement technique : - Les requ\u00eates partent vers l\u2019API ECS (Spring Boot + PostgreSQL) - Le monitoring passe par Prometheus + Grafana</p> <p>Cela permet, en entretien, de montrer : - Que le contrat fonctionnel est le m\u00eame - Que seule l\u2019impl\u00e9mentation backend change (ECS vs Serverless)</p>"},{"location":"guide/quickstart/#ce-quil-faut-retenir-pour-lentretien","title":"\ud83e\udde0 Ce qu\u2019il faut retenir pour l\u2019entretien","text":"<ul> <li>Le projet ne force pas le lecteur \u00e0 ex\u00e9cuter des commandes : tout est pilotable par l\u2019UI.</li> <li>Le frontend masque la complexit\u00e9 (Terraform, CI/CD, AWS), l\u2019utilisateur voit juste :</li> <li>Choix du mode (ECS / Serverless)</li> <li>Cr\u00e9ation et suivi de simulations</li> <li>Visualisation dans Grafana</li> <li>C\u2019est donc un bac \u00e0 sable IoT pour comparer deux architectures cloud en conditions quasi r\u00e9elles, avec :</li> <li>Les m\u00eames \u00e9crans</li> <li>Les m\u00eames APIs</li> <li>Des stacks techniques radicalement diff\u00e9rentes sous le capot.</li> </ul>"},{"location":"guide/simulations/","title":"Gestion des simulations","text":"<p>Cette page d\u00e9crit la logique m\u00e9tier autour des simulations (runs), vue c\u00f4t\u00e9 utilisateur et c\u00f4t\u00e9 architecture.</p>"},{"location":"guide/simulations/#concepts-cles","title":"\ud83e\udde9 Concepts cl\u00e9s","text":"<ul> <li>Run : une simulation de capteurs sur une p\u00e9riode donn\u00e9e (ex: 60s avec une mesure toutes les 5s)</li> <li>Sensor : un capteur logique (temp\u00e9rature, multi-mesures, etc.)</li> <li>User : actuellement, tous les utilisateurs partagent la m\u00eame \"piscine\" de runs (limite globale \u00e0 5), mais le header <code>X-User</code> permet de tracer qui a lanc\u00e9 quoi.</li> </ul>"},{"location":"guide/simulations/#actions-possibles","title":"\ud83c\udfae Actions possibles","text":"<p>Depuis le frontend, l'utilisateur peut :</p> <ol> <li>V\u00e9rifier s'il peut d\u00e9marrer une simulation    \u2192 Endpoint <code>/api/runs/can-start</code> qui renvoie :</li> <li><code>canStart</code> (bool\u00e9en)</li> <li><code>currentRunning</code> (nombre de runs actifs)</li> <li> <p><code>maxAllowed</code> (limite globale, 5)</p> </li> <li> <p>D\u00e9marrer une simulation    \u2192 <code>/api/runs/start</code> avec la dur\u00e9e et l'intervalle. Le backend :</p> </li> <li>V\u00e9rifie la limite</li> <li>Cr\u00e9e un run <code>RUNNING</code> dans la base (PostgreSQL ou DynamoDB selon le mode)</li> <li> <p>G\u00e9n\u00e8re une URL Grafana pr\u00e9-filtr\u00e9e sur ce run</p> </li> <li> <p>Lister les simulations en cours    \u2192 <code>/api/runs/running</code> pour voir les runs <code>RUNNING</code>.</p> </li> <li> <p>Terminer une simulation    \u2192 <code>/api/runs/{id}/finish</code> pour passer le run \u00e0 <code>COMPLETED</code>.</p> </li> <li> <p>Interrompre toutes les simulations    \u2192 <code>/api/runs/interrupt-all</code> qui met \u00e0 jour tous les runs <code>RUNNING</code> vers <code>INTERRUPTED</code>.</p> </li> </ol>"},{"location":"guide/simulations/#cycle-de-vie-dun-run","title":"\ud83d\udd01 Cycle de vie d'un run","text":"<p>\u00c9tats principaux d'un run :</p> <ul> <li><code>RUNNING</code> : simulation active</li> <li><code>COMPLETED</code> : s'est termin\u00e9e normalement</li> <li><code>FAILED</code> : erreur (ex: probl\u00e8me technique)</li> <li><code>INTERRUPTED</code> : arr\u00eat manuel via l'API</li> </ul> <p>En entretien, tu peux insister sur le fait que cette logique m\u00e9tier est identique en ECS et en Serverless, ce qui renforce la comparaison technique entre les deux architectures.</p>"},{"location":"guide/simulations/#points-interessants-a-mentionner","title":"\ud83e\udde0 Points int\u00e9ressants \u00e0 mentionner","text":"<ul> <li>La limite globale \u00e0 5 runs illustre la gestion d'un quota simple c\u00f4t\u00e9 backend.</li> <li><code>X-User</code> est d\u00e9j\u00e0 en place pour pr\u00e9parer une \u00e9volution vers des quotas par utilisateur.</li> <li>Chaque run est li\u00e9 \u00e0 une URL Grafana sp\u00e9cifique, ce qui cr\u00e9e un pont clair entre la couche m\u00e9tier et l'observabilit\u00e9.</li> </ul>"},{"location":"modules/compute/","title":"Modules Compute (ECS &amp; Lambda)","text":"<p>Cette section d\u00e9crit comment la puissance de calcul est factoris\u00e9e en modules Terraform.</p>"},{"location":"modules/compute/#ecs-module-ecs","title":"\ud83d\udc33 ECS (module <code>ecs</code>)","text":"<ul> <li>D\u00e9finit un cluster ECS Fargate partag\u00e9 pour :</li> <li>L\u2019application Spring Boot</li> <li>Prometheus</li> <li>Grafana (mode ECS classique)</li> <li>Param\u00e8tres typiques :</li> <li>vCPU / m\u00e9moire par t\u00e2che</li> <li>Auto-scaling possible selon la charge</li> </ul> <p>Id\u00e9e cl\u00e9 : encapsuler toute la brique \"cluster conteneurs\" dans un module unique.</p>"},{"location":"modules/compute/#lambda-modules-serverlesslambda_","title":"\u26a1 Lambda (modules <code>serverless/lambda_*</code>)","text":"<p>Modules d\u00e9di\u00e9s : - <code>lambda_run_api</code> :   - Fonction Python pour g\u00e9rer les runs (can-start, start, finish, interrupt-all\u2026)   - Connect\u00e9e \u00e0 DynamoDB (table Runs)   - Expos\u00e9e via API Gateway - <code>lambda_sensor_api</code> :   - Fonction Python pour l\u2019ingestion des donn\u00e9es capteurs   - Connect\u00e9e \u00e0 DynamoDB (table SensorData)   - Expos\u00e9e via API Gateway</p> <p>Id\u00e9e cl\u00e9 : chaque Lambda a son module, avec ses variables propres (noms de tables, URL Grafana, etc.), mais suit les m\u00eames conventions (tags, logs, IAM).</p>"},{"location":"modules/compute/#ce-que-ca-montre","title":"\ud83d\udd0d Ce que \u00e7a montre","text":"<ul> <li>Une approche modulaire c\u00f4t\u00e9 compute : on peut faire \u00e9voluer ECS ou Lambda ind\u00e9pendamment.</li> <li>Possibilit\u00e9 de r\u00e9utiliser ces modules dans d\u2019autres environnements (staging, prod\u2026).</li> <li>En entretien, tu peux montrer que tu sais d\u00e9couper proprement la couche compute entre conteneurs et fonctions serverless.</li> </ul>"},{"location":"modules/database/","title":"Modules Base de donn\u00e9es (RDS &amp; DynamoDB)","text":"<p>Cette partie couvre les deux approches de stockage : - RDS PostgreSQL pour l\u2019architecture ECS - DynamoDB pour l\u2019architecture Serverless</p>"},{"location":"modules/database/#rds-postgresql-module-database","title":"\ud83d\udc18 RDS PostgreSQL (module <code>database</code>)","text":"<ul> <li>Cr\u00e9e une instance RDS dans des subnets priv\u00e9s</li> <li>G\u00e9r\u00e9 via le module <code>infra/modules/database</code></li> <li>Utilis\u00e9 par :</li> <li>Environnement <code>dev</code> (Spring Boot)</li> </ul> <p>R\u00f4le : stocker les runs et les donn\u00e9es capteurs dans un mod\u00e8le relationnel classique.</p>"},{"location":"modules/database/#dynamodb-module-serverlessdynamodb_tables","title":"\ud83e\uddfe DynamoDB (module <code>serverless/dynamodb_tables</code>)","text":"<ul> <li>Cr\u00e9e deux tables principales :</li> <li><code>Runs</code> : m\u00e9tadonn\u00e9es des simulations</li> <li><code>SensorData</code> : donn\u00e9es de capteurs</li> <li>Mode on-demand (pay-per-request)</li> <li>Utilis\u00e9 par :</li> <li>Environnement <code>serverless-dev</code></li> </ul> <p>R\u00f4le : fournir un stockage scalable, sans gestion de serveur, parfaitement adapt\u00e9 aux Lambdas.</p>"},{"location":"modules/database/#angle-a-presenter-en-entretien","title":"\ud83d\udd0d Angle \u00e0 pr\u00e9senter en entretien","text":"<ul> <li>Tu as volontairement mis en regard deux types de stockage : relationnel vs NoSQL.</li> <li>La logique m\u00e9tier reste la m\u00eame (Runs + SensorData), seul le mod\u00e8le de donn\u00e9es change.</li> <li>C\u2019est un excellent support pour discuter de :</li> <li>transactions vs scalabilit\u00e9</li> <li>sch\u00e9ma fix\u00e9 vs flexible</li> <li>co\u00fbts et patterns d\u2019acc\u00e8s.</li> </ul>"},{"location":"modules/monitoring/","title":"Modules Monitoring &amp; Observabilit\u00e9","text":"<p>Cette partie regroupe les briques li\u00e9es \u00e0 la visibilit\u00e9 sur le syst\u00e8me : m\u00e9triques, logs, dashboards.</p>"},{"location":"modules/monitoring/#grafana-ecs-module-grafana_ecs","title":"\ud83d\udcc8 Grafana ECS (module <code>grafana_ecs</code>)","text":"<ul> <li>D\u00e9ploie un conteneur Grafana sur ECS Fargate</li> <li>S\u2019appuie sur :</li> <li>un ALB (HTTPS)</li> <li>un VPC (subnets publics/priv\u00e9s)</li> <li>Datasources :</li> <li>Prometheus (mode ECS)</li> <li>CloudWatch (mode Serverless)</li> </ul>"},{"location":"modules/monitoring/#prometheus-via-ecs","title":"\ud83d\udcca Prometheus (via ECS)","text":"<ul> <li>D\u00e9ploy\u00e9 dans l\u2019architecture ECS</li> <li>Scrape les m\u00e9triques Spring Boot (<code>/actuator/prometheus</code>)</li> <li>Sert de datasource principale \u00e0 Grafana dans ce mode.</li> </ul>"},{"location":"modules/monitoring/#cloudwatch-serverless","title":"\ud83d\udc40 CloudWatch (Serverless)","text":"<ul> <li>Les Lambdas envoient leurs logs dans CloudWatch Logs</li> <li>Des m\u00e9triques custom sont d\u00e9riv\u00e9es pour alimenter les dashboards Grafana :</li> <li>nombre de runs d\u00e9marr\u00e9s/termin\u00e9s</li> <li>volume de donn\u00e9es capteur</li> <li>latence / erreurs des Lambdas</li> </ul>"},{"location":"modules/monitoring/#a-vendre-en-entretien","title":"\ud83d\udd0d \u00c0 vendre en entretien","text":"<ul> <li>Tu as deux cha\u00eenes de monitoring :</li> <li>ECS \u2192 Prometheus \u2192 Grafana</li> <li>Lambda \u2192 CloudWatch \u2192 Grafana</li> <li>Mais une exp\u00e9rience unifi\u00e9e c\u00f4t\u00e9 utilisateur (m\u00eames filtres : Run, User, Sensor).</li> <li>L\u2019observabilit\u00e9 fait partie int\u00e9grante du design, pas un ajout de derni\u00e8re minute.</li> </ul>"},{"location":"modules/network/","title":"Module R\u00e9seau (VPC &amp; Subnets)","text":""},{"location":"modules/network/#utilisation-dans-le-projet","title":"\ud83e\udde9 Utilisation dans le projet","text":"<ul> <li>Cette structure est proche des best practices AWS (2\u20133 AZ, subnets publics/priv\u00e9s, etc.).</li> <li>On s\u00e9pare clairement les ressources expos\u00e9es (ALB) des ressources priv\u00e9es (ECS/RDS/Grafana).</li> <li>Le r\u00e9seau est factoris\u00e9 dans un module pour \u00e9viter la duplication.</li> </ul>"},{"location":"modules/network/#points-a-mentionner-en-entretien","title":"\ud83d\udca1 Points \u00e0 mentionner en entretien","text":"<ul> <li>VPC d\u00e9di\u00e9 pour Grafana serverless (s\u00e9par\u00e9 du reste)</li> <li>Environnement <code>grafana-serverless-dev</code> :</li> <li>VPC principal pour ECS, RDS, Prometheus, Grafana</li> <li> <p>Environnement <code>dev</code> (ECS) :</p> </li> <li> <p>Acc\u00e8s limit\u00e9 entrant via ALB uniquement</p> </li> <li>Acc\u00e8s Internet sortant</li> <li>Configurer les routes pour :</li> <li>D\u00e9couper en subnets publics (ALB, NAT, bastion) et subnets priv\u00e9s (ECS, RDS, Grafana)</li> <li>Cr\u00e9er un VPC isol\u00e9</li> </ul>"},{"location":"modules/network/#role-du-module","title":"\ud83c\udfaf R\u00f4le du module","text":"<p>Ce module g\u00e8re la partie r\u00e9seau commune : VPC, sous-r\u00e9seaux, tables de routage, Internet Gateway, etc.</p>"},{"location":"modules/structure/","title":"Vue d'ensemble des modules Terraform","text":"<p>Cette section pr\u00e9sente la structure Terraform du projet sans entrer dans les d\u00e9tails de syntaxe. L'objectif est de montrer comment l'infrastructure est d\u00e9coup\u00e9e en briques r\u00e9utilisables.</p> <p>En entretien, tu peux t'appuyer sur cette page pour montrer que la partie Terraform est pens\u00e9e de mani\u00e8re modulaire et maintenable, sans plonger dans le code brut.</p>"},{"location":"modules/structure/#organisation-generale","title":"\ud83e\uddf1 Organisation g\u00e9n\u00e9rale","text":"<p>Le r\u00e9pertoire <code>infra/modules/</code> contient des modules utilis\u00e9s par plusieurs environnements :</p> <ul> <li>Modules \u00ab classiques \u00bb : r\u00e9seau, ECS, RDS, ALB, certificats, Grafana ECS\u2026</li> <li>Modules \u00ab serverless \u00bb : DynamoDB, Lambdas, API Gateway, VPC d\u00e9di\u00e9 Grafana\u2026</li> </ul> <p>L'id\u00e9e est de pouvoir : - Recomposer facilement une architecture ECS ou Serverless - Garder une coh\u00e9rence entre les environnements (<code>dev</code>, <code>serverless-dev</code>, <code>inframanager-dev</code>, ...) - Faire \u00e9voluer l\u2019infra en ajoutant un nouvel environnement (ex: <code>serverless-staging</code>) en r\u00e9utilisant les m\u00eames briques.</p>"},{"location":"modules/structure/#arborescence-simplifiee","title":"\ud83d\udcc2 Arborescence (simplifi\u00e9e)","text":"<pre><code>infra/\n\u251c\u2500\u2500 envs/\n\u2502   \u251c\u2500\u2500 dev/                # Environnement ECS classique\n\u2502   \u251c\u2500\u2500 serverless-dev/     # Environnement Serverless (Lambda)\n\u2502   \u2514\u2500\u2500 inframanager-dev/   # Environnement Infra Manager ECS\n\u2514\u2500\u2500 modules/\n    \u251c\u2500\u2500 network/            # VPC, subnets, route tables\n    \u251c\u2500\u2500 ecs/                # Cluster ECS de base\n    \u251c\u2500\u2500 database/           # RDS PostgreSQL\n    \u251c\u2500\u2500 alb/                # Application Load Balancer\n    \u251c\u2500\u2500 acm_certificate/    # Certificats ACM\n    \u251c\u2500\u2500 grafana_ecs/        # Grafana sur ECS (mode classique + serverless)\n    \u2514\u2500\u2500 serverless/\n        \u251c\u2500\u2500 dynamodb_tables/\n        \u251c\u2500\u2500 lambda_run_api/\n        \u251c\u2500\u2500 lambda_sensor_api/\n        \u251c\u2500\u2500 api_gateway_lambda_iot/\n        \u2514\u2500\u2500 vpc/            # VPC d\u00e9di\u00e9 Grafana serverless\n</code></pre>"},{"location":"modules/structure/#principes-de-design","title":"\ud83c\udfaf Principes de design","text":"<ul> <li>S\u00e9paration des responsabilit\u00e9s :</li> <li><code>network</code> pour le r\u00e9seau</li> <li><code>ecs</code> / <code>database</code> / <code>alb</code> pour le backend ECS</li> <li><code>serverless/*</code> pour la partie Lambda + DynamoDB + API Gateway</li> <li> <p><code>grafana_ecs</code> pour la brique d\u2019observabilit\u00e9 commune</p> </li> <li> <p>R\u00e9utilisation :</p> </li> <li>Les m\u00eames modules r\u00e9seau / s\u00e9curit\u00e9 servent \u00e0 ECS et Grafana serverless.</li> <li> <p>Les modules serverless peuvent \u00eatre branch\u00e9s sur d'autres environnements futurs.</p> </li> <li> <p>Lisibilit\u00e9 :</p> </li> <li>Chaque environnement (<code>dev</code>, <code>serverless-dev</code>, <code>inframanager-dev</code>) assemble ces briques de mani\u00e8re d\u00e9clarative dans son propre <code>main.tf</code>.</li> </ul> <p>En un coup d\u2019\u0153il, cette page doit te permettre d\u2019expliquer comment est structur\u00e9e l\u2019infra sans ouvrir un seul fichier <code>.tf</code> pendant l\u2019entretien.</p>"}]}